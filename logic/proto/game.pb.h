// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: game.proto

#ifndef PROTOBUF_INCLUDED_game_2eproto
#define PROTOBUF_INCLUDED_game_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "data.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_game_2eproto 

namespace protobuf_game_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[29];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_game_2eproto
class oCdInfo;
class oCdInfoDefaultTypeInternal;
extern oCdInfoDefaultTypeInternal _oCdInfo_default_instance_;
class oClientChallengeCancelReq;
class oClientChallengeCancelReqDefaultTypeInternal;
extern oClientChallengeCancelReqDefaultTypeInternal _oClientChallengeCancelReq_default_instance_;
class oClientCreateChallengeForFriendReq;
class oClientCreateChallengeForFriendReqDefaultTypeInternal;
extern oClientCreateChallengeForFriendReqDefaultTypeInternal _oClientCreateChallengeForFriendReq_default_instance_;
class oClientGameReadyPush;
class oClientGameReadyPushDefaultTypeInternal;
extern oClientGameReadyPushDefaultTypeInternal _oClientGameReadyPush_default_instance_;
class oClientJoinChallengeReq;
class oClientJoinChallengeReqDefaultTypeInternal;
extern oClientJoinChallengeReqDefaultTypeInternal _oClientJoinChallengeReq_default_instance_;
class oClientLoginReq;
class oClientLoginReqDefaultTypeInternal;
extern oClientLoginReqDefaultTypeInternal _oClientLoginReq_default_instance_;
class oClientMatchReq;
class oClientMatchReqDefaultTypeInternal;
extern oClientMatchReqDefaultTypeInternal _oClientMatchReq_default_instance_;
class oClientSoldiersGoToBattlePush;
class oClientSoldiersGoToBattlePushDefaultTypeInternal;
extern oClientSoldiersGoToBattlePushDefaultTypeInternal _oClientSoldiersGoToBattlePush_default_instance_;
class oMatcherInfo;
class oMatcherInfoDefaultTypeInternal;
extern oMatcherInfoDefaultTypeInternal _oMatcherInfo_default_instance_;
class oRolesInfo;
class oRolesInfoDefaultTypeInternal;
extern oRolesInfoDefaultTypeInternal _oRolesInfo_default_instance_;
class oServerCastSkillPush;
class oServerCastSkillPushDefaultTypeInternal;
extern oServerCastSkillPushDefaultTypeInternal _oServerCastSkillPush_default_instance_;
class oServerChallengeCancelAws;
class oServerChallengeCancelAwsDefaultTypeInternal;
extern oServerChallengeCancelAwsDefaultTypeInternal _oServerChallengeCancelAws_default_instance_;
class oServerCreateBuff;
class oServerCreateBuffDefaultTypeInternal;
extern oServerCreateBuffDefaultTypeInternal _oServerCreateBuff_default_instance_;
class oServerCreateChallengeForFriendAws;
class oServerCreateChallengeForFriendAwsDefaultTypeInternal;
extern oServerCreateChallengeForFriendAwsDefaultTypeInternal _oServerCreateChallengeForFriendAws_default_instance_;
class oServerCreateSceneEffect;
class oServerCreateSceneEffectDefaultTypeInternal;
extern oServerCreateSceneEffectDefaultTypeInternal _oServerCreateSceneEffect_default_instance_;
class oServerGameFrame;
class oServerGameFrameDefaultTypeInternal;
extern oServerGameFrameDefaultTypeInternal _oServerGameFrame_default_instance_;
class oServerGameOverPush;
class oServerGameOverPushDefaultTypeInternal;
extern oServerGameOverPushDefaultTypeInternal _oServerGameOverPush_default_instance_;
class oServerGameStartPush;
class oServerGameStartPushDefaultTypeInternal;
extern oServerGameStartPushDefaultTypeInternal _oServerGameStartPush_default_instance_;
class oServerGameStatementsPush;
class oServerGameStatementsPushDefaultTypeInternal;
extern oServerGameStatementsPushDefaultTypeInternal _oServerGameStatementsPush_default_instance_;
class oServerLoginAws;
class oServerLoginAwsDefaultTypeInternal;
extern oServerLoginAwsDefaultTypeInternal _oServerLoginAws_default_instance_;
class oServerMatchAws;
class oServerMatchAwsDefaultTypeInternal;
extern oServerMatchAwsDefaultTypeInternal _oServerMatchAws_default_instance_;
class oServerPointChangePush;
class oServerPointChangePushDefaultTypeInternal;
extern oServerPointChangePushDefaultTypeInternal _oServerPointChangePush_default_instance_;
class oServerRemoveBuff;
class oServerRemoveBuffDefaultTypeInternal;
extern oServerRemoveBuffDefaultTypeInternal _oServerRemoveBuff_default_instance_;
class oServerRemoveSceneEffect;
class oServerRemoveSceneEffectDefaultTypeInternal;
extern oServerRemoveSceneEffectDefaultTypeInternal _oServerRemoveSceneEffect_default_instance_;
class oServerResumeGamePush;
class oServerResumeGamePushDefaultTypeInternal;
extern oServerResumeGamePushDefaultTypeInternal _oServerResumeGamePush_default_instance_;
class oServerRoleQueueUpdatePush;
class oServerRoleQueueUpdatePushDefaultTypeInternal;
extern oServerRoleQueueUpdatePushDefaultTypeInternal _oServerRoleQueueUpdatePush_default_instance_;
class oServerRoleThrustingPush;
class oServerRoleThrustingPushDefaultTypeInternal;
extern oServerRoleThrustingPushDefaultTypeInternal _oServerRoleThrustingPush_default_instance_;
class oServerRolesGoToBattlePush;
class oServerRolesGoToBattlePushDefaultTypeInternal;
extern oServerRolesGoToBattlePushDefaultTypeInternal _oServerRolesGoToBattlePush_default_instance_;
class oServerRolesLeaveBattlePush;
class oServerRolesLeaveBattlePushDefaultTypeInternal;
extern oServerRolesLeaveBattlePushDefaultTypeInternal _oServerRolesLeaveBattlePush_default_instance_;
namespace google {
namespace protobuf {
template<> ::oCdInfo* Arena::CreateMaybeMessage<::oCdInfo>(Arena*);
template<> ::oClientChallengeCancelReq* Arena::CreateMaybeMessage<::oClientChallengeCancelReq>(Arena*);
template<> ::oClientCreateChallengeForFriendReq* Arena::CreateMaybeMessage<::oClientCreateChallengeForFriendReq>(Arena*);
template<> ::oClientGameReadyPush* Arena::CreateMaybeMessage<::oClientGameReadyPush>(Arena*);
template<> ::oClientJoinChallengeReq* Arena::CreateMaybeMessage<::oClientJoinChallengeReq>(Arena*);
template<> ::oClientLoginReq* Arena::CreateMaybeMessage<::oClientLoginReq>(Arena*);
template<> ::oClientMatchReq* Arena::CreateMaybeMessage<::oClientMatchReq>(Arena*);
template<> ::oClientSoldiersGoToBattlePush* Arena::CreateMaybeMessage<::oClientSoldiersGoToBattlePush>(Arena*);
template<> ::oMatcherInfo* Arena::CreateMaybeMessage<::oMatcherInfo>(Arena*);
template<> ::oRolesInfo* Arena::CreateMaybeMessage<::oRolesInfo>(Arena*);
template<> ::oServerCastSkillPush* Arena::CreateMaybeMessage<::oServerCastSkillPush>(Arena*);
template<> ::oServerChallengeCancelAws* Arena::CreateMaybeMessage<::oServerChallengeCancelAws>(Arena*);
template<> ::oServerCreateBuff* Arena::CreateMaybeMessage<::oServerCreateBuff>(Arena*);
template<> ::oServerCreateChallengeForFriendAws* Arena::CreateMaybeMessage<::oServerCreateChallengeForFriendAws>(Arena*);
template<> ::oServerCreateSceneEffect* Arena::CreateMaybeMessage<::oServerCreateSceneEffect>(Arena*);
template<> ::oServerGameFrame* Arena::CreateMaybeMessage<::oServerGameFrame>(Arena*);
template<> ::oServerGameOverPush* Arena::CreateMaybeMessage<::oServerGameOverPush>(Arena*);
template<> ::oServerGameStartPush* Arena::CreateMaybeMessage<::oServerGameStartPush>(Arena*);
template<> ::oServerGameStatementsPush* Arena::CreateMaybeMessage<::oServerGameStatementsPush>(Arena*);
template<> ::oServerLoginAws* Arena::CreateMaybeMessage<::oServerLoginAws>(Arena*);
template<> ::oServerMatchAws* Arena::CreateMaybeMessage<::oServerMatchAws>(Arena*);
template<> ::oServerPointChangePush* Arena::CreateMaybeMessage<::oServerPointChangePush>(Arena*);
template<> ::oServerRemoveBuff* Arena::CreateMaybeMessage<::oServerRemoveBuff>(Arena*);
template<> ::oServerRemoveSceneEffect* Arena::CreateMaybeMessage<::oServerRemoveSceneEffect>(Arena*);
template<> ::oServerResumeGamePush* Arena::CreateMaybeMessage<::oServerResumeGamePush>(Arena*);
template<> ::oServerRoleQueueUpdatePush* Arena::CreateMaybeMessage<::oServerRoleQueueUpdatePush>(Arena*);
template<> ::oServerRoleThrustingPush* Arena::CreateMaybeMessage<::oServerRoleThrustingPush>(Arena*);
template<> ::oServerRolesGoToBattlePush* Arena::CreateMaybeMessage<::oServerRolesGoToBattlePush>(Arena*);
template<> ::oServerRolesLeaveBattlePush* Arena::CreateMaybeMessage<::oServerRolesLeaveBattlePush>(Arena*);
}  // namespace protobuf
}  // namespace google

enum eError {
  unknown = 0,
  success = 1,
  already_in_game = 2,
  already_in_match = 3,
  system_http_request_error = 4,
  eError_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  eError_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool eError_IsValid(int value);
const eError eError_MIN = unknown;
const eError eError_MAX = system_http_request_error;
const int eError_ARRAYSIZE = eError_MAX + 1;

const ::google::protobuf::EnumDescriptor* eError_descriptor();
inline const ::std::string& eError_Name(eError value) {
  return ::google::protobuf::internal::NameOfEnum(
    eError_descriptor(), value);
}
inline bool eError_Parse(
    const ::std::string& name, eError* value) {
  return ::google::protobuf::internal::ParseNamedEnum<eError>(
    eError_descriptor(), name, value);
}
enum eCProtoID {
  ClientLoginReq = 0,
  ClientMatchReq = 1,
  ClientCreateChallengeForFriendReq = 2,
  ClientJoinChallengeReq = 3,
  ClientChallengeCancelReq = 4,
  ClientGameReadyPush = 5,
  ClientSoldiersGoToBattlePush = 6,
  eCProtoID_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  eCProtoID_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool eCProtoID_IsValid(int value);
const eCProtoID eCProtoID_MIN = ClientLoginReq;
const eCProtoID eCProtoID_MAX = ClientSoldiersGoToBattlePush;
const int eCProtoID_ARRAYSIZE = eCProtoID_MAX + 1;

const ::google::protobuf::EnumDescriptor* eCProtoID_descriptor();
inline const ::std::string& eCProtoID_Name(eCProtoID value) {
  return ::google::protobuf::internal::NameOfEnum(
    eCProtoID_descriptor(), value);
}
inline bool eCProtoID_Parse(
    const ::std::string& name, eCProtoID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<eCProtoID>(
    eCProtoID_descriptor(), name, value);
}
enum eSProtoID {
  ServerLoginAws = 0,
  ServerMatchAws = 1,
  ServerCreateChallengeForFriendAws = 2,
  ServerChallengeCancelAws = 3,
  ServerGameStartPush = 4,
  ServerResumeGamePush = 5,
  ServerRolesGoToBattlePush = 50,
  ServerRolesLeaveBattlePush = 51,
  ServerRoleQueueUpdatePush = 52,
  ServerRoleThrustingPush = 53,
  ServerGameFrame = 54,
  ServerGameOverPush = 55,
  ServerGameStatementsPush = 56,
  ServerPointChangePush = 57,
  ServerCastSkillPush = 58,
  ServerCreateBuff = 59,
  ServerRemoveBuff = 60,
  ServerCreateSceneEffect = 61,
  ServerRemoveSceneEffect = 62,
  eSProtoID_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  eSProtoID_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool eSProtoID_IsValid(int value);
const eSProtoID eSProtoID_MIN = ServerLoginAws;
const eSProtoID eSProtoID_MAX = ServerRemoveSceneEffect;
const int eSProtoID_ARRAYSIZE = eSProtoID_MAX + 1;

const ::google::protobuf::EnumDescriptor* eSProtoID_descriptor();
inline const ::std::string& eSProtoID_Name(eSProtoID value) {
  return ::google::protobuf::internal::NameOfEnum(
    eSProtoID_descriptor(), value);
}
inline bool eSProtoID_Parse(
    const ::std::string& name, eSProtoID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<eSProtoID>(
    eSProtoID_descriptor(), name, value);
}
enum ePlatform {
  try_ = 0,
  wechat = 1,
  ePlatform_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ePlatform_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ePlatform_IsValid(int value);
const ePlatform ePlatform_MIN = try_;
const ePlatform ePlatform_MAX = wechat;
const int ePlatform_ARRAYSIZE = ePlatform_MAX + 1;

const ::google::protobuf::EnumDescriptor* ePlatform_descriptor();
inline const ::std::string& ePlatform_Name(ePlatform value) {
  return ::google::protobuf::internal::NameOfEnum(
    ePlatform_descriptor(), value);
}
inline bool ePlatform_Parse(
    const ::std::string& name, ePlatform* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ePlatform>(
    ePlatform_descriptor(), name, value);
}
enum eGameState {
  loading_data = 0,
  load_data_error = 1,
  loaded_data = 2,
  ready = 4,
  eGameState_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  eGameState_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool eGameState_IsValid(int value);
const eGameState eGameState_MIN = loading_data;
const eGameState eGameState_MAX = ready;
const int eGameState_ARRAYSIZE = eGameState_MAX + 1;

const ::google::protobuf::EnumDescriptor* eGameState_descriptor();
inline const ::std::string& eGameState_Name(eGameState value) {
  return ::google::protobuf::internal::NameOfEnum(
    eGameState_descriptor(), value);
}
inline bool eGameState_Parse(
    const ::std::string& name, eGameState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<eGameState>(
    eGameState_descriptor(), name, value);
}
enum eRoleState {
  in_queue = 0,
  in_orbit = 1,
  thrusting = 2,
  eRoleState_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  eRoleState_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool eRoleState_IsValid(int value);
const eRoleState eRoleState_MIN = in_queue;
const eRoleState eRoleState_MAX = thrusting;
const int eRoleState_ARRAYSIZE = eRoleState_MAX + 1;

const ::google::protobuf::EnumDescriptor* eRoleState_descriptor();
inline const ::std::string& eRoleState_Name(eRoleState value) {
  return ::google::protobuf::internal::NameOfEnum(
    eRoleState_descriptor(), value);
}
inline bool eRoleState_Parse(
    const ::std::string& name, eRoleState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<eRoleState>(
    eRoleState_descriptor(), name, value);
}
enum eSide {
  top = 0,
  bottom = 1,
  eSide_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  eSide_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool eSide_IsValid(int value);
const eSide eSide_MIN = top;
const eSide eSide_MAX = bottom;
const int eSide_ARRAYSIZE = eSide_MAX + 1;

const ::google::protobuf::EnumDescriptor* eSide_descriptor();
inline const ::std::string& eSide_Name(eSide value) {
  return ::google::protobuf::internal::NameOfEnum(
    eSide_descriptor(), value);
}
inline bool eSide_Parse(
    const ::std::string& name, eSide* value) {
  return ::google::protobuf::internal::ParseNamedEnum<eSide>(
    eSide_descriptor(), name, value);
}
enum eGameResult {
  lose = 0,
  draw = 1,
  win = 2,
  eGameResult_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  eGameResult_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool eGameResult_IsValid(int value);
const eGameResult eGameResult_MIN = lose;
const eGameResult eGameResult_MAX = win;
const int eGameResult_ARRAYSIZE = eGameResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* eGameResult_descriptor();
inline const ::std::string& eGameResult_Name(eGameResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    eGameResult_descriptor(), value);
}
inline bool eGameResult_Parse(
    const ::std::string& name, eGameResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<eGameResult>(
    eGameResult_descriptor(), name, value);
}
// ===================================================================

class oClientLoginReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oClientLoginReq) */ {
 public:
  oClientLoginReq();
  virtual ~oClientLoginReq();

  oClientLoginReq(const oClientLoginReq& from);

  inline oClientLoginReq& operator=(const oClientLoginReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  oClientLoginReq(oClientLoginReq&& from) noexcept
    : oClientLoginReq() {
    *this = ::std::move(from);
  }

  inline oClientLoginReq& operator=(oClientLoginReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const oClientLoginReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const oClientLoginReq* internal_default_instance() {
    return reinterpret_cast<const oClientLoginReq*>(
               &_oClientLoginReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(oClientLoginReq* other);
  friend void swap(oClientLoginReq& a, oClientLoginReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline oClientLoginReq* New() const final {
    return CreateMaybeMessage<oClientLoginReq>(NULL);
  }

  oClientLoginReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<oClientLoginReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const oClientLoginReq& from);
  void MergeFrom(const oClientLoginReq& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(oClientLoginReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string token = 3;
  void clear_token();
  static const int kTokenFieldNumber = 3;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  #if LANG_CXX11
  void set_token(::std::string&& value);
  #endif
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // .ePlatform platform = 1;
  void clear_platform();
  static const int kPlatformFieldNumber = 1;
  ::ePlatform platform() const;
  void set_platform(::ePlatform value);

  // int32 account = 2;
  void clear_account();
  static const int kAccountFieldNumber = 2;
  ::google::protobuf::int32 account() const;
  void set_account(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:oClientLoginReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  int platform_;
  ::google::protobuf::int32 account_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class oServerLoginAws : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oServerLoginAws) */ {
 public:
  oServerLoginAws();
  virtual ~oServerLoginAws();

  oServerLoginAws(const oServerLoginAws& from);

  inline oServerLoginAws& operator=(const oServerLoginAws& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  oServerLoginAws(oServerLoginAws&& from) noexcept
    : oServerLoginAws() {
    *this = ::std::move(from);
  }

  inline oServerLoginAws& operator=(oServerLoginAws&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const oServerLoginAws& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const oServerLoginAws* internal_default_instance() {
    return reinterpret_cast<const oServerLoginAws*>(
               &_oServerLoginAws_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(oServerLoginAws* other);
  friend void swap(oServerLoginAws& a, oServerLoginAws& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline oServerLoginAws* New() const final {
    return CreateMaybeMessage<oServerLoginAws>(NULL);
  }

  oServerLoginAws* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<oServerLoginAws>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const oServerLoginAws& from);
  void MergeFrom(const oServerLoginAws& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(oServerLoginAws* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .oIdentity account = 2;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 2;
  private:
  const ::oIdentity& _internal_account() const;
  public:
  const ::oIdentity& account() const;
  ::oIdentity* release_account();
  ::oIdentity* mutable_account();
  void set_allocated_account(::oIdentity* account);

  // .eError code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::eError code() const;
  void set_code(::eError value);

  // @@protoc_insertion_point(class_scope:oServerLoginAws)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::oIdentity* account_;
  int code_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class oClientMatchReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oClientMatchReq) */ {
 public:
  oClientMatchReq();
  virtual ~oClientMatchReq();

  oClientMatchReq(const oClientMatchReq& from);

  inline oClientMatchReq& operator=(const oClientMatchReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  oClientMatchReq(oClientMatchReq&& from) noexcept
    : oClientMatchReq() {
    *this = ::std::move(from);
  }

  inline oClientMatchReq& operator=(oClientMatchReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const oClientMatchReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const oClientMatchReq* internal_default_instance() {
    return reinterpret_cast<const oClientMatchReq*>(
               &_oClientMatchReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(oClientMatchReq* other);
  friend void swap(oClientMatchReq& a, oClientMatchReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline oClientMatchReq* New() const final {
    return CreateMaybeMessage<oClientMatchReq>(NULL);
  }

  oClientMatchReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<oClientMatchReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const oClientMatchReq& from);
  void MergeFrom(const oClientMatchReq& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(oClientMatchReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:oClientMatchReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class oMatcherInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oMatcherInfo) */ {
 public:
  oMatcherInfo();
  virtual ~oMatcherInfo();

  oMatcherInfo(const oMatcherInfo& from);

  inline oMatcherInfo& operator=(const oMatcherInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  oMatcherInfo(oMatcherInfo&& from) noexcept
    : oMatcherInfo() {
    *this = ::std::move(from);
  }

  inline oMatcherInfo& operator=(oMatcherInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const oMatcherInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const oMatcherInfo* internal_default_instance() {
    return reinterpret_cast<const oMatcherInfo*>(
               &_oMatcherInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(oMatcherInfo* other);
  friend void swap(oMatcherInfo& a, oMatcherInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline oMatcherInfo* New() const final {
    return CreateMaybeMessage<oMatcherInfo>(NULL);
  }

  oMatcherInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<oMatcherInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const oMatcherInfo& from);
  void MergeFrom(const oMatcherInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(oMatcherInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 used_card_config_id = 2;
  int used_card_config_id_size() const;
  void clear_used_card_config_id();
  static const int kUsedCardConfigIdFieldNumber = 2;
  ::google::protobuf::int32 used_card_config_id(int index) const;
  void set_used_card_config_id(int index, ::google::protobuf::int32 value);
  void add_used_card_config_id(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      used_card_config_id() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_used_card_config_id();

  // .oUnit player_info = 1;
  bool has_player_info() const;
  void clear_player_info();
  static const int kPlayerInfoFieldNumber = 1;
  private:
  const ::oUnit& _internal_player_info() const;
  public:
  const ::oUnit& player_info() const;
  ::oUnit* release_player_info();
  ::oUnit* mutable_player_info();
  void set_allocated_player_info(::oUnit* player_info);

  // @@protoc_insertion_point(class_scope:oMatcherInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > used_card_config_id_;
  mutable int _used_card_config_id_cached_byte_size_;
  ::oUnit* player_info_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class oServerMatchAws : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oServerMatchAws) */ {
 public:
  oServerMatchAws();
  virtual ~oServerMatchAws();

  oServerMatchAws(const oServerMatchAws& from);

  inline oServerMatchAws& operator=(const oServerMatchAws& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  oServerMatchAws(oServerMatchAws&& from) noexcept
    : oServerMatchAws() {
    *this = ::std::move(from);
  }

  inline oServerMatchAws& operator=(oServerMatchAws&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const oServerMatchAws& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const oServerMatchAws* internal_default_instance() {
    return reinterpret_cast<const oServerMatchAws*>(
               &_oServerMatchAws_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(oServerMatchAws* other);
  friend void swap(oServerMatchAws& a, oServerMatchAws& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline oServerMatchAws* New() const final {
    return CreateMaybeMessage<oServerMatchAws>(NULL);
  }

  oServerMatchAws* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<oServerMatchAws>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const oServerMatchAws& from);
  void MergeFrom(const oServerMatchAws& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(oServerMatchAws* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .oMatcherInfo matcher_info = 3;
  int matcher_info_size() const;
  void clear_matcher_info();
  static const int kMatcherInfoFieldNumber = 3;
  ::oMatcherInfo* mutable_matcher_info(int index);
  ::google::protobuf::RepeatedPtrField< ::oMatcherInfo >*
      mutable_matcher_info();
  const ::oMatcherInfo& matcher_info(int index) const;
  ::oMatcherInfo* add_matcher_info();
  const ::google::protobuf::RepeatedPtrField< ::oMatcherInfo >&
      matcher_info() const;

  // .oUnit scene = 2;
  bool has_scene() const;
  void clear_scene();
  static const int kSceneFieldNumber = 2;
  private:
  const ::oUnit& _internal_scene() const;
  public:
  const ::oUnit& scene() const;
  ::oUnit* release_scene();
  ::oUnit* mutable_scene();
  void set_allocated_scene(::oUnit* scene);

  // .eError code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::eError code() const;
  void set_code(::eError value);

  // @@protoc_insertion_point(class_scope:oServerMatchAws)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::oMatcherInfo > matcher_info_;
  ::oUnit* scene_;
  int code_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class oClientCreateChallengeForFriendReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oClientCreateChallengeForFriendReq) */ {
 public:
  oClientCreateChallengeForFriendReq();
  virtual ~oClientCreateChallengeForFriendReq();

  oClientCreateChallengeForFriendReq(const oClientCreateChallengeForFriendReq& from);

  inline oClientCreateChallengeForFriendReq& operator=(const oClientCreateChallengeForFriendReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  oClientCreateChallengeForFriendReq(oClientCreateChallengeForFriendReq&& from) noexcept
    : oClientCreateChallengeForFriendReq() {
    *this = ::std::move(from);
  }

  inline oClientCreateChallengeForFriendReq& operator=(oClientCreateChallengeForFriendReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const oClientCreateChallengeForFriendReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const oClientCreateChallengeForFriendReq* internal_default_instance() {
    return reinterpret_cast<const oClientCreateChallengeForFriendReq*>(
               &_oClientCreateChallengeForFriendReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(oClientCreateChallengeForFriendReq* other);
  friend void swap(oClientCreateChallengeForFriendReq& a, oClientCreateChallengeForFriendReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline oClientCreateChallengeForFriendReq* New() const final {
    return CreateMaybeMessage<oClientCreateChallengeForFriendReq>(NULL);
  }

  oClientCreateChallengeForFriendReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<oClientCreateChallengeForFriendReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const oClientCreateChallengeForFriendReq& from);
  void MergeFrom(const oClientCreateChallengeForFriendReq& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(oClientCreateChallengeForFriendReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:oClientCreateChallengeForFriendReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class oClientJoinChallengeReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oClientJoinChallengeReq) */ {
 public:
  oClientJoinChallengeReq();
  virtual ~oClientJoinChallengeReq();

  oClientJoinChallengeReq(const oClientJoinChallengeReq& from);

  inline oClientJoinChallengeReq& operator=(const oClientJoinChallengeReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  oClientJoinChallengeReq(oClientJoinChallengeReq&& from) noexcept
    : oClientJoinChallengeReq() {
    *this = ::std::move(from);
  }

  inline oClientJoinChallengeReq& operator=(oClientJoinChallengeReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const oClientJoinChallengeReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const oClientJoinChallengeReq* internal_default_instance() {
    return reinterpret_cast<const oClientJoinChallengeReq*>(
               &_oClientJoinChallengeReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(oClientJoinChallengeReq* other);
  friend void swap(oClientJoinChallengeReq& a, oClientJoinChallengeReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline oClientJoinChallengeReq* New() const final {
    return CreateMaybeMessage<oClientJoinChallengeReq>(NULL);
  }

  oClientJoinChallengeReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<oClientJoinChallengeReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const oClientJoinChallengeReq& from);
  void MergeFrom(const oClientJoinChallengeReq& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(oClientJoinChallengeReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .oIdentity challenge_id = 1;
  bool has_challenge_id() const;
  void clear_challenge_id();
  static const int kChallengeIdFieldNumber = 1;
  private:
  const ::oIdentity& _internal_challenge_id() const;
  public:
  const ::oIdentity& challenge_id() const;
  ::oIdentity* release_challenge_id();
  ::oIdentity* mutable_challenge_id();
  void set_allocated_challenge_id(::oIdentity* challenge_id);

  // @@protoc_insertion_point(class_scope:oClientJoinChallengeReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::oIdentity* challenge_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class oServerCreateChallengeForFriendAws : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oServerCreateChallengeForFriendAws) */ {
 public:
  oServerCreateChallengeForFriendAws();
  virtual ~oServerCreateChallengeForFriendAws();

  oServerCreateChallengeForFriendAws(const oServerCreateChallengeForFriendAws& from);

  inline oServerCreateChallengeForFriendAws& operator=(const oServerCreateChallengeForFriendAws& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  oServerCreateChallengeForFriendAws(oServerCreateChallengeForFriendAws&& from) noexcept
    : oServerCreateChallengeForFriendAws() {
    *this = ::std::move(from);
  }

  inline oServerCreateChallengeForFriendAws& operator=(oServerCreateChallengeForFriendAws&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const oServerCreateChallengeForFriendAws& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const oServerCreateChallengeForFriendAws* internal_default_instance() {
    return reinterpret_cast<const oServerCreateChallengeForFriendAws*>(
               &_oServerCreateChallengeForFriendAws_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(oServerCreateChallengeForFriendAws* other);
  friend void swap(oServerCreateChallengeForFriendAws& a, oServerCreateChallengeForFriendAws& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline oServerCreateChallengeForFriendAws* New() const final {
    return CreateMaybeMessage<oServerCreateChallengeForFriendAws>(NULL);
  }

  oServerCreateChallengeForFriendAws* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<oServerCreateChallengeForFriendAws>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const oServerCreateChallengeForFriendAws& from);
  void MergeFrom(const oServerCreateChallengeForFriendAws& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(oServerCreateChallengeForFriendAws* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .oIdentity challenge_id = 2;
  bool has_challenge_id() const;
  void clear_challenge_id();
  static const int kChallengeIdFieldNumber = 2;
  private:
  const ::oIdentity& _internal_challenge_id() const;
  public:
  const ::oIdentity& challenge_id() const;
  ::oIdentity* release_challenge_id();
  ::oIdentity* mutable_challenge_id();
  void set_allocated_challenge_id(::oIdentity* challenge_id);

  // .eError code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::eError code() const;
  void set_code(::eError value);

  // @@protoc_insertion_point(class_scope:oServerCreateChallengeForFriendAws)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::oIdentity* challenge_id_;
  int code_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class oClientChallengeCancelReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oClientChallengeCancelReq) */ {
 public:
  oClientChallengeCancelReq();
  virtual ~oClientChallengeCancelReq();

  oClientChallengeCancelReq(const oClientChallengeCancelReq& from);

  inline oClientChallengeCancelReq& operator=(const oClientChallengeCancelReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  oClientChallengeCancelReq(oClientChallengeCancelReq&& from) noexcept
    : oClientChallengeCancelReq() {
    *this = ::std::move(from);
  }

  inline oClientChallengeCancelReq& operator=(oClientChallengeCancelReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const oClientChallengeCancelReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const oClientChallengeCancelReq* internal_default_instance() {
    return reinterpret_cast<const oClientChallengeCancelReq*>(
               &_oClientChallengeCancelReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(oClientChallengeCancelReq* other);
  friend void swap(oClientChallengeCancelReq& a, oClientChallengeCancelReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline oClientChallengeCancelReq* New() const final {
    return CreateMaybeMessage<oClientChallengeCancelReq>(NULL);
  }

  oClientChallengeCancelReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<oClientChallengeCancelReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const oClientChallengeCancelReq& from);
  void MergeFrom(const oClientChallengeCancelReq& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(oClientChallengeCancelReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:oClientChallengeCancelReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class oServerChallengeCancelAws : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oServerChallengeCancelAws) */ {
 public:
  oServerChallengeCancelAws();
  virtual ~oServerChallengeCancelAws();

  oServerChallengeCancelAws(const oServerChallengeCancelAws& from);

  inline oServerChallengeCancelAws& operator=(const oServerChallengeCancelAws& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  oServerChallengeCancelAws(oServerChallengeCancelAws&& from) noexcept
    : oServerChallengeCancelAws() {
    *this = ::std::move(from);
  }

  inline oServerChallengeCancelAws& operator=(oServerChallengeCancelAws&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const oServerChallengeCancelAws& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const oServerChallengeCancelAws* internal_default_instance() {
    return reinterpret_cast<const oServerChallengeCancelAws*>(
               &_oServerChallengeCancelAws_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(oServerChallengeCancelAws* other);
  friend void swap(oServerChallengeCancelAws& a, oServerChallengeCancelAws& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline oServerChallengeCancelAws* New() const final {
    return CreateMaybeMessage<oServerChallengeCancelAws>(NULL);
  }

  oServerChallengeCancelAws* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<oServerChallengeCancelAws>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const oServerChallengeCancelAws& from);
  void MergeFrom(const oServerChallengeCancelAws& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(oServerChallengeCancelAws* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .eError code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::eError code() const;
  void set_code(::eError value);

  // @@protoc_insertion_point(class_scope:oServerChallengeCancelAws)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int code_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class oClientGameReadyPush : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oClientGameReadyPush) */ {
 public:
  oClientGameReadyPush();
  virtual ~oClientGameReadyPush();

  oClientGameReadyPush(const oClientGameReadyPush& from);

  inline oClientGameReadyPush& operator=(const oClientGameReadyPush& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  oClientGameReadyPush(oClientGameReadyPush&& from) noexcept
    : oClientGameReadyPush() {
    *this = ::std::move(from);
  }

  inline oClientGameReadyPush& operator=(oClientGameReadyPush&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const oClientGameReadyPush& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const oClientGameReadyPush* internal_default_instance() {
    return reinterpret_cast<const oClientGameReadyPush*>(
               &_oClientGameReadyPush_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(oClientGameReadyPush* other);
  friend void swap(oClientGameReadyPush& a, oClientGameReadyPush& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline oClientGameReadyPush* New() const final {
    return CreateMaybeMessage<oClientGameReadyPush>(NULL);
  }

  oClientGameReadyPush* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<oClientGameReadyPush>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const oClientGameReadyPush& from);
  void MergeFrom(const oClientGameReadyPush& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(oClientGameReadyPush* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:oClientGameReadyPush)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class oRolesInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oRolesInfo) */ {
 public:
  oRolesInfo();
  virtual ~oRolesInfo();

  oRolesInfo(const oRolesInfo& from);

  inline oRolesInfo& operator=(const oRolesInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  oRolesInfo(oRolesInfo&& from) noexcept
    : oRolesInfo() {
    *this = ::std::move(from);
  }

  inline oRolesInfo& operator=(oRolesInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const oRolesInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const oRolesInfo* internal_default_instance() {
    return reinterpret_cast<const oRolesInfo*>(
               &_oRolesInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(oRolesInfo* other);
  friend void swap(oRolesInfo& a, oRolesInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline oRolesInfo* New() const final {
    return CreateMaybeMessage<oRolesInfo>(NULL);
  }

  oRolesInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<oRolesInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const oRolesInfo& from);
  void MergeFrom(const oRolesInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(oRolesInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .oUnit roles = 2;
  int roles_size() const;
  void clear_roles();
  static const int kRolesFieldNumber = 2;
  ::oUnit* mutable_roles(int index);
  ::google::protobuf::RepeatedPtrField< ::oUnit >*
      mutable_roles();
  const ::oUnit& roles(int index) const;
  ::oUnit* add_roles();
  const ::google::protobuf::RepeatedPtrField< ::oUnit >&
      roles() const;

  // .oIdentity account = 1;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  private:
  const ::oIdentity& _internal_account() const;
  public:
  const ::oIdentity& account() const;
  ::oIdentity* release_account();
  ::oIdentity* mutable_account();
  void set_allocated_account(::oIdentity* account);

  // @@protoc_insertion_point(class_scope:oRolesInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::oUnit > roles_;
  ::oIdentity* account_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class oServerGameStartPush : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oServerGameStartPush) */ {
 public:
  oServerGameStartPush();
  virtual ~oServerGameStartPush();

  oServerGameStartPush(const oServerGameStartPush& from);

  inline oServerGameStartPush& operator=(const oServerGameStartPush& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  oServerGameStartPush(oServerGameStartPush&& from) noexcept
    : oServerGameStartPush() {
    *this = ::std::move(from);
  }

  inline oServerGameStartPush& operator=(oServerGameStartPush&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const oServerGameStartPush& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const oServerGameStartPush* internal_default_instance() {
    return reinterpret_cast<const oServerGameStartPush*>(
               &_oServerGameStartPush_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(oServerGameStartPush* other);
  friend void swap(oServerGameStartPush& a, oServerGameStartPush& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline oServerGameStartPush* New() const final {
    return CreateMaybeMessage<oServerGameStartPush>(NULL);
  }

  oServerGameStartPush* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<oServerGameStartPush>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const oServerGameStartPush& from);
  void MergeFrom(const oServerGameStartPush& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(oServerGameStartPush* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .oRolesInfo info = 1;
  int info_size() const;
  void clear_info();
  static const int kInfoFieldNumber = 1;
  ::oRolesInfo* mutable_info(int index);
  ::google::protobuf::RepeatedPtrField< ::oRolesInfo >*
      mutable_info();
  const ::oRolesInfo& info(int index) const;
  ::oRolesInfo* add_info();
  const ::google::protobuf::RepeatedPtrField< ::oRolesInfo >&
      info() const;

  // @@protoc_insertion_point(class_scope:oServerGameStartPush)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::oRolesInfo > info_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class oClientSoldiersGoToBattlePush : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oClientSoldiersGoToBattlePush) */ {
 public:
  oClientSoldiersGoToBattlePush();
  virtual ~oClientSoldiersGoToBattlePush();

  oClientSoldiersGoToBattlePush(const oClientSoldiersGoToBattlePush& from);

  inline oClientSoldiersGoToBattlePush& operator=(const oClientSoldiersGoToBattlePush& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  oClientSoldiersGoToBattlePush(oClientSoldiersGoToBattlePush&& from) noexcept
    : oClientSoldiersGoToBattlePush() {
    *this = ::std::move(from);
  }

  inline oClientSoldiersGoToBattlePush& operator=(oClientSoldiersGoToBattlePush&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const oClientSoldiersGoToBattlePush& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const oClientSoldiersGoToBattlePush* internal_default_instance() {
    return reinterpret_cast<const oClientSoldiersGoToBattlePush*>(
               &_oClientSoldiersGoToBattlePush_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(oClientSoldiersGoToBattlePush* other);
  friend void swap(oClientSoldiersGoToBattlePush& a, oClientSoldiersGoToBattlePush& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline oClientSoldiersGoToBattlePush* New() const final {
    return CreateMaybeMessage<oClientSoldiersGoToBattlePush>(NULL);
  }

  oClientSoldiersGoToBattlePush* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<oClientSoldiersGoToBattlePush>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const oClientSoldiersGoToBattlePush& from);
  void MergeFrom(const oClientSoldiersGoToBattlePush& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(oClientSoldiersGoToBattlePush* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 orbit_number = 1;
  void clear_orbit_number();
  static const int kOrbitNumberFieldNumber = 1;
  ::google::protobuf::int32 orbit_number() const;
  void set_orbit_number(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:oClientSoldiersGoToBattlePush)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 orbit_number_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class oServerRolesGoToBattlePush : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oServerRolesGoToBattlePush) */ {
 public:
  oServerRolesGoToBattlePush();
  virtual ~oServerRolesGoToBattlePush();

  oServerRolesGoToBattlePush(const oServerRolesGoToBattlePush& from);

  inline oServerRolesGoToBattlePush& operator=(const oServerRolesGoToBattlePush& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  oServerRolesGoToBattlePush(oServerRolesGoToBattlePush&& from) noexcept
    : oServerRolesGoToBattlePush() {
    *this = ::std::move(from);
  }

  inline oServerRolesGoToBattlePush& operator=(oServerRolesGoToBattlePush&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const oServerRolesGoToBattlePush& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const oServerRolesGoToBattlePush* internal_default_instance() {
    return reinterpret_cast<const oServerRolesGoToBattlePush*>(
               &_oServerRolesGoToBattlePush_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(oServerRolesGoToBattlePush* other);
  friend void swap(oServerRolesGoToBattlePush& a, oServerRolesGoToBattlePush& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline oServerRolesGoToBattlePush* New() const final {
    return CreateMaybeMessage<oServerRolesGoToBattlePush>(NULL);
  }

  oServerRolesGoToBattlePush* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<oServerRolesGoToBattlePush>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const oServerRolesGoToBattlePush& from);
  void MergeFrom(const oServerRolesGoToBattlePush& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(oServerRolesGoToBattlePush* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .oIdentity account = 1;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  private:
  const ::oIdentity& _internal_account() const;
  public:
  const ::oIdentity& account() const;
  ::oIdentity* release_account();
  ::oIdentity* mutable_account();
  void set_allocated_account(::oIdentity* account);

  // .oUnit role = 3;
  bool has_role() const;
  void clear_role();
  static const int kRoleFieldNumber = 3;
  private:
  const ::oUnit& _internal_role() const;
  public:
  const ::oUnit& role() const;
  ::oUnit* release_role();
  ::oUnit* mutable_role();
  void set_allocated_role(::oUnit* role);

  // int32 orbit_number = 2;
  void clear_orbit_number();
  static const int kOrbitNumberFieldNumber = 2;
  ::google::protobuf::int32 orbit_number() const;
  void set_orbit_number(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:oServerRolesGoToBattlePush)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::oIdentity* account_;
  ::oUnit* role_;
  ::google::protobuf::int32 orbit_number_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class oServerRoleQueueUpdatePush : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oServerRoleQueueUpdatePush) */ {
 public:
  oServerRoleQueueUpdatePush();
  virtual ~oServerRoleQueueUpdatePush();

  oServerRoleQueueUpdatePush(const oServerRoleQueueUpdatePush& from);

  inline oServerRoleQueueUpdatePush& operator=(const oServerRoleQueueUpdatePush& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  oServerRoleQueueUpdatePush(oServerRoleQueueUpdatePush&& from) noexcept
    : oServerRoleQueueUpdatePush() {
    *this = ::std::move(from);
  }

  inline oServerRoleQueueUpdatePush& operator=(oServerRoleQueueUpdatePush&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const oServerRoleQueueUpdatePush& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const oServerRoleQueueUpdatePush* internal_default_instance() {
    return reinterpret_cast<const oServerRoleQueueUpdatePush*>(
               &_oServerRoleQueueUpdatePush_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(oServerRoleQueueUpdatePush* other);
  friend void swap(oServerRoleQueueUpdatePush& a, oServerRoleQueueUpdatePush& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline oServerRoleQueueUpdatePush* New() const final {
    return CreateMaybeMessage<oServerRoleQueueUpdatePush>(NULL);
  }

  oServerRoleQueueUpdatePush* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<oServerRoleQueueUpdatePush>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const oServerRoleQueueUpdatePush& from);
  void MergeFrom(const oServerRoleQueueUpdatePush& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(oServerRoleQueueUpdatePush* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .oUnit role = 1;
  int role_size() const;
  void clear_role();
  static const int kRoleFieldNumber = 1;
  ::oUnit* mutable_role(int index);
  ::google::protobuf::RepeatedPtrField< ::oUnit >*
      mutable_role();
  const ::oUnit& role(int index) const;
  ::oUnit* add_role();
  const ::google::protobuf::RepeatedPtrField< ::oUnit >&
      role() const;

  // @@protoc_insertion_point(class_scope:oServerRoleQueueUpdatePush)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::oUnit > role_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class oServerRolesLeaveBattlePush : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oServerRolesLeaveBattlePush) */ {
 public:
  oServerRolesLeaveBattlePush();
  virtual ~oServerRolesLeaveBattlePush();

  oServerRolesLeaveBattlePush(const oServerRolesLeaveBattlePush& from);

  inline oServerRolesLeaveBattlePush& operator=(const oServerRolesLeaveBattlePush& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  oServerRolesLeaveBattlePush(oServerRolesLeaveBattlePush&& from) noexcept
    : oServerRolesLeaveBattlePush() {
    *this = ::std::move(from);
  }

  inline oServerRolesLeaveBattlePush& operator=(oServerRolesLeaveBattlePush&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const oServerRolesLeaveBattlePush& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const oServerRolesLeaveBattlePush* internal_default_instance() {
    return reinterpret_cast<const oServerRolesLeaveBattlePush*>(
               &_oServerRolesLeaveBattlePush_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(oServerRolesLeaveBattlePush* other);
  friend void swap(oServerRolesLeaveBattlePush& a, oServerRolesLeaveBattlePush& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline oServerRolesLeaveBattlePush* New() const final {
    return CreateMaybeMessage<oServerRolesLeaveBattlePush>(NULL);
  }

  oServerRolesLeaveBattlePush* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<oServerRolesLeaveBattlePush>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const oServerRolesLeaveBattlePush& from);
  void MergeFrom(const oServerRolesLeaveBattlePush& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(oServerRolesLeaveBattlePush* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .oIdentity roles = 1;
  int roles_size() const;
  void clear_roles();
  static const int kRolesFieldNumber = 1;
  ::oIdentity* mutable_roles(int index);
  ::google::protobuf::RepeatedPtrField< ::oIdentity >*
      mutable_roles();
  const ::oIdentity& roles(int index) const;
  ::oIdentity* add_roles();
  const ::google::protobuf::RepeatedPtrField< ::oIdentity >&
      roles() const;

  // @@protoc_insertion_point(class_scope:oServerRolesLeaveBattlePush)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::oIdentity > roles_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class oCdInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oCdInfo) */ {
 public:
  oCdInfo();
  virtual ~oCdInfo();

  oCdInfo(const oCdInfo& from);

  inline oCdInfo& operator=(const oCdInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  oCdInfo(oCdInfo&& from) noexcept
    : oCdInfo() {
    *this = ::std::move(from);
  }

  inline oCdInfo& operator=(oCdInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const oCdInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const oCdInfo* internal_default_instance() {
    return reinterpret_cast<const oCdInfo*>(
               &_oCdInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(oCdInfo* other);
  friend void swap(oCdInfo& a, oCdInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline oCdInfo* New() const final {
    return CreateMaybeMessage<oCdInfo>(NULL);
  }

  oCdInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<oCdInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const oCdInfo& from);
  void MergeFrom(const oCdInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(oCdInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .oIdentity account = 1;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  private:
  const ::oIdentity& _internal_account() const;
  public:
  const ::oIdentity& account() const;
  ::oIdentity* release_account();
  ::oIdentity* mutable_account();
  void set_allocated_account(::oIdentity* account);

  // int32 cd = 2;
  void clear_cd();
  static const int kCdFieldNumber = 2;
  ::google::protobuf::int32 cd() const;
  void set_cd(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:oCdInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::oIdentity* account_;
  ::google::protobuf::int32 cd_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class oServerGameFrame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oServerGameFrame) */ {
 public:
  oServerGameFrame();
  virtual ~oServerGameFrame();

  oServerGameFrame(const oServerGameFrame& from);

  inline oServerGameFrame& operator=(const oServerGameFrame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  oServerGameFrame(oServerGameFrame&& from) noexcept
    : oServerGameFrame() {
    *this = ::std::move(from);
  }

  inline oServerGameFrame& operator=(oServerGameFrame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const oServerGameFrame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const oServerGameFrame* internal_default_instance() {
    return reinterpret_cast<const oServerGameFrame*>(
               &_oServerGameFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(oServerGameFrame* other);
  friend void swap(oServerGameFrame& a, oServerGameFrame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline oServerGameFrame* New() const final {
    return CreateMaybeMessage<oServerGameFrame>(NULL);
  }

  oServerGameFrame* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<oServerGameFrame>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const oServerGameFrame& from);
  void MergeFrom(const oServerGameFrame& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(oServerGameFrame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .oUnit roles = 1;
  int roles_size() const;
  void clear_roles();
  static const int kRolesFieldNumber = 1;
  ::oUnit* mutable_roles(int index);
  ::google::protobuf::RepeatedPtrField< ::oUnit >*
      mutable_roles();
  const ::oUnit& roles(int index) const;
  ::oUnit* add_roles();
  const ::google::protobuf::RepeatedPtrField< ::oUnit >&
      roles() const;

  // repeated .oCdInfo cdinfos = 2;
  int cdinfos_size() const;
  void clear_cdinfos();
  static const int kCdinfosFieldNumber = 2;
  ::oCdInfo* mutable_cdinfos(int index);
  ::google::protobuf::RepeatedPtrField< ::oCdInfo >*
      mutable_cdinfos();
  const ::oCdInfo& cdinfos(int index) const;
  ::oCdInfo* add_cdinfos();
  const ::google::protobuf::RepeatedPtrField< ::oCdInfo >&
      cdinfos() const;

  // int32 game_time = 3;
  void clear_game_time();
  static const int kGameTimeFieldNumber = 3;
  ::google::protobuf::int32 game_time() const;
  void set_game_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:oServerGameFrame)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::oUnit > roles_;
  ::google::protobuf::RepeatedPtrField< ::oCdInfo > cdinfos_;
  ::google::protobuf::int32 game_time_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class oServerRoleThrustingPush : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oServerRoleThrustingPush) */ {
 public:
  oServerRoleThrustingPush();
  virtual ~oServerRoleThrustingPush();

  oServerRoleThrustingPush(const oServerRoleThrustingPush& from);

  inline oServerRoleThrustingPush& operator=(const oServerRoleThrustingPush& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  oServerRoleThrustingPush(oServerRoleThrustingPush&& from) noexcept
    : oServerRoleThrustingPush() {
    *this = ::std::move(from);
  }

  inline oServerRoleThrustingPush& operator=(oServerRoleThrustingPush&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const oServerRoleThrustingPush& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const oServerRoleThrustingPush* internal_default_instance() {
    return reinterpret_cast<const oServerRoleThrustingPush*>(
               &_oServerRoleThrustingPush_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(oServerRoleThrustingPush* other);
  friend void swap(oServerRoleThrustingPush& a, oServerRoleThrustingPush& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline oServerRoleThrustingPush* New() const final {
    return CreateMaybeMessage<oServerRoleThrustingPush>(NULL);
  }

  oServerRoleThrustingPush* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<oServerRoleThrustingPush>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const oServerRoleThrustingPush& from);
  void MergeFrom(const oServerRoleThrustingPush& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(oServerRoleThrustingPush* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .oIdentity ids = 1;
  int ids_size() const;
  void clear_ids();
  static const int kIdsFieldNumber = 1;
  ::oIdentity* mutable_ids(int index);
  ::google::protobuf::RepeatedPtrField< ::oIdentity >*
      mutable_ids();
  const ::oIdentity& ids(int index) const;
  ::oIdentity* add_ids();
  const ::google::protobuf::RepeatedPtrField< ::oIdentity >&
      ids() const;

  // @@protoc_insertion_point(class_scope:oServerRoleThrustingPush)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::oIdentity > ids_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class oServerPointChangePush : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oServerPointChangePush) */ {
 public:
  oServerPointChangePush();
  virtual ~oServerPointChangePush();

  oServerPointChangePush(const oServerPointChangePush& from);

  inline oServerPointChangePush& operator=(const oServerPointChangePush& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  oServerPointChangePush(oServerPointChangePush&& from) noexcept
    : oServerPointChangePush() {
    *this = ::std::move(from);
  }

  inline oServerPointChangePush& operator=(oServerPointChangePush&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const oServerPointChangePush& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const oServerPointChangePush* internal_default_instance() {
    return reinterpret_cast<const oServerPointChangePush*>(
               &_oServerPointChangePush_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(oServerPointChangePush* other);
  friend void swap(oServerPointChangePush& a, oServerPointChangePush& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline oServerPointChangePush* New() const final {
    return CreateMaybeMessage<oServerPointChangePush>(NULL);
  }

  oServerPointChangePush* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<oServerPointChangePush>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const oServerPointChangePush& from);
  void MergeFrom(const oServerPointChangePush& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(oServerPointChangePush* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .oIdentity account = 1;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  private:
  const ::oIdentity& _internal_account() const;
  public:
  const ::oIdentity& account() const;
  ::oIdentity* release_account();
  ::oIdentity* mutable_account();
  void set_allocated_account(::oIdentity* account);

  // int32 point = 2;
  void clear_point();
  static const int kPointFieldNumber = 2;
  ::google::protobuf::int32 point() const;
  void set_point(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:oServerPointChangePush)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::oIdentity* account_;
  ::google::protobuf::int32 point_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class oServerCreateSceneEffect : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oServerCreateSceneEffect) */ {
 public:
  oServerCreateSceneEffect();
  virtual ~oServerCreateSceneEffect();

  oServerCreateSceneEffect(const oServerCreateSceneEffect& from);

  inline oServerCreateSceneEffect& operator=(const oServerCreateSceneEffect& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  oServerCreateSceneEffect(oServerCreateSceneEffect&& from) noexcept
    : oServerCreateSceneEffect() {
    *this = ::std::move(from);
  }

  inline oServerCreateSceneEffect& operator=(oServerCreateSceneEffect&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const oServerCreateSceneEffect& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const oServerCreateSceneEffect* internal_default_instance() {
    return reinterpret_cast<const oServerCreateSceneEffect*>(
               &_oServerCreateSceneEffect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(oServerCreateSceneEffect* other);
  friend void swap(oServerCreateSceneEffect& a, oServerCreateSceneEffect& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline oServerCreateSceneEffect* New() const final {
    return CreateMaybeMessage<oServerCreateSceneEffect>(NULL);
  }

  oServerCreateSceneEffect* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<oServerCreateSceneEffect>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const oServerCreateSceneEffect& from);
  void MergeFrom(const oServerCreateSceneEffect& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(oServerCreateSceneEffect* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .oIdentity effectid = 1;
  bool has_effectid() const;
  void clear_effectid();
  static const int kEffectidFieldNumber = 1;
  private:
  const ::oIdentity& _internal_effectid() const;
  public:
  const ::oIdentity& effectid() const;
  ::oIdentity* release_effectid();
  ::oIdentity* mutable_effectid();
  void set_allocated_effectid(::oIdentity* effectid);

  // int32 configid = 2;
  void clear_configid();
  static const int kConfigidFieldNumber = 2;
  ::google::protobuf::int32 configid() const;
  void set_configid(::google::protobuf::int32 value);

  // int32 oribt_number = 3;
  void clear_oribt_number();
  static const int kOribtNumberFieldNumber = 3;
  ::google::protobuf::int32 oribt_number() const;
  void set_oribt_number(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:oServerCreateSceneEffect)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::oIdentity* effectid_;
  ::google::protobuf::int32 configid_;
  ::google::protobuf::int32 oribt_number_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class oServerRemoveSceneEffect : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oServerRemoveSceneEffect) */ {
 public:
  oServerRemoveSceneEffect();
  virtual ~oServerRemoveSceneEffect();

  oServerRemoveSceneEffect(const oServerRemoveSceneEffect& from);

  inline oServerRemoveSceneEffect& operator=(const oServerRemoveSceneEffect& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  oServerRemoveSceneEffect(oServerRemoveSceneEffect&& from) noexcept
    : oServerRemoveSceneEffect() {
    *this = ::std::move(from);
  }

  inline oServerRemoveSceneEffect& operator=(oServerRemoveSceneEffect&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const oServerRemoveSceneEffect& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const oServerRemoveSceneEffect* internal_default_instance() {
    return reinterpret_cast<const oServerRemoveSceneEffect*>(
               &_oServerRemoveSceneEffect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(oServerRemoveSceneEffect* other);
  friend void swap(oServerRemoveSceneEffect& a, oServerRemoveSceneEffect& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline oServerRemoveSceneEffect* New() const final {
    return CreateMaybeMessage<oServerRemoveSceneEffect>(NULL);
  }

  oServerRemoveSceneEffect* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<oServerRemoveSceneEffect>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const oServerRemoveSceneEffect& from);
  void MergeFrom(const oServerRemoveSceneEffect& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(oServerRemoveSceneEffect* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .oIdentity effectid = 1;
  bool has_effectid() const;
  void clear_effectid();
  static const int kEffectidFieldNumber = 1;
  private:
  const ::oIdentity& _internal_effectid() const;
  public:
  const ::oIdentity& effectid() const;
  ::oIdentity* release_effectid();
  ::oIdentity* mutable_effectid();
  void set_allocated_effectid(::oIdentity* effectid);

  // @@protoc_insertion_point(class_scope:oServerRemoveSceneEffect)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::oIdentity* effectid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class oServerCastSkillPush : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oServerCastSkillPush) */ {
 public:
  oServerCastSkillPush();
  virtual ~oServerCastSkillPush();

  oServerCastSkillPush(const oServerCastSkillPush& from);

  inline oServerCastSkillPush& operator=(const oServerCastSkillPush& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  oServerCastSkillPush(oServerCastSkillPush&& from) noexcept
    : oServerCastSkillPush() {
    *this = ::std::move(from);
  }

  inline oServerCastSkillPush& operator=(oServerCastSkillPush&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const oServerCastSkillPush& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const oServerCastSkillPush* internal_default_instance() {
    return reinterpret_cast<const oServerCastSkillPush*>(
               &_oServerCastSkillPush_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(oServerCastSkillPush* other);
  friend void swap(oServerCastSkillPush& a, oServerCastSkillPush& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline oServerCastSkillPush* New() const final {
    return CreateMaybeMessage<oServerCastSkillPush>(NULL);
  }

  oServerCastSkillPush* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<oServerCastSkillPush>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const oServerCastSkillPush& from);
  void MergeFrom(const oServerCastSkillPush& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(oServerCastSkillPush* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .oIdentity roles = 3;
  int roles_size() const;
  void clear_roles();
  static const int kRolesFieldNumber = 3;
  ::oIdentity* mutable_roles(int index);
  ::google::protobuf::RepeatedPtrField< ::oIdentity >*
      mutable_roles();
  const ::oIdentity& roles(int index) const;
  ::oIdentity* add_roles();
  const ::google::protobuf::RepeatedPtrField< ::oIdentity >&
      roles() const;

  // .oIdentity caster = 1;
  bool has_caster() const;
  void clear_caster();
  static const int kCasterFieldNumber = 1;
  private:
  const ::oIdentity& _internal_caster() const;
  public:
  const ::oIdentity& caster() const;
  ::oIdentity* release_caster();
  ::oIdentity* mutable_caster();
  void set_allocated_caster(::oIdentity* caster);

  // int32 skillid = 2;
  void clear_skillid();
  static const int kSkillidFieldNumber = 2;
  ::google::protobuf::int32 skillid() const;
  void set_skillid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:oServerCastSkillPush)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::oIdentity > roles_;
  ::oIdentity* caster_;
  ::google::protobuf::int32 skillid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class oServerCreateBuff : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oServerCreateBuff) */ {
 public:
  oServerCreateBuff();
  virtual ~oServerCreateBuff();

  oServerCreateBuff(const oServerCreateBuff& from);

  inline oServerCreateBuff& operator=(const oServerCreateBuff& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  oServerCreateBuff(oServerCreateBuff&& from) noexcept
    : oServerCreateBuff() {
    *this = ::std::move(from);
  }

  inline oServerCreateBuff& operator=(oServerCreateBuff&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const oServerCreateBuff& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const oServerCreateBuff* internal_default_instance() {
    return reinterpret_cast<const oServerCreateBuff*>(
               &_oServerCreateBuff_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(oServerCreateBuff* other);
  friend void swap(oServerCreateBuff& a, oServerCreateBuff& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline oServerCreateBuff* New() const final {
    return CreateMaybeMessage<oServerCreateBuff>(NULL);
  }

  oServerCreateBuff* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<oServerCreateBuff>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const oServerCreateBuff& from);
  void MergeFrom(const oServerCreateBuff& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(oServerCreateBuff* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .oIdentity roles = 3;
  int roles_size() const;
  void clear_roles();
  static const int kRolesFieldNumber = 3;
  ::oIdentity* mutable_roles(int index);
  ::google::protobuf::RepeatedPtrField< ::oIdentity >*
      mutable_roles();
  const ::oIdentity& roles(int index) const;
  ::oIdentity* add_roles();
  const ::google::protobuf::RepeatedPtrField< ::oIdentity >&
      roles() const;

  // .oIdentity buffid = 1;
  bool has_buffid() const;
  void clear_buffid();
  static const int kBuffidFieldNumber = 1;
  private:
  const ::oIdentity& _internal_buffid() const;
  public:
  const ::oIdentity& buffid() const;
  ::oIdentity* release_buffid();
  ::oIdentity* mutable_buffid();
  void set_allocated_buffid(::oIdentity* buffid);

  // int32 configid = 2;
  void clear_configid();
  static const int kConfigidFieldNumber = 2;
  ::google::protobuf::int32 configid() const;
  void set_configid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:oServerCreateBuff)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::oIdentity > roles_;
  ::oIdentity* buffid_;
  ::google::protobuf::int32 configid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class oServerRemoveBuff : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oServerRemoveBuff) */ {
 public:
  oServerRemoveBuff();
  virtual ~oServerRemoveBuff();

  oServerRemoveBuff(const oServerRemoveBuff& from);

  inline oServerRemoveBuff& operator=(const oServerRemoveBuff& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  oServerRemoveBuff(oServerRemoveBuff&& from) noexcept
    : oServerRemoveBuff() {
    *this = ::std::move(from);
  }

  inline oServerRemoveBuff& operator=(oServerRemoveBuff&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const oServerRemoveBuff& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const oServerRemoveBuff* internal_default_instance() {
    return reinterpret_cast<const oServerRemoveBuff*>(
               &_oServerRemoveBuff_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(oServerRemoveBuff* other);
  friend void swap(oServerRemoveBuff& a, oServerRemoveBuff& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline oServerRemoveBuff* New() const final {
    return CreateMaybeMessage<oServerRemoveBuff>(NULL);
  }

  oServerRemoveBuff* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<oServerRemoveBuff>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const oServerRemoveBuff& from);
  void MergeFrom(const oServerRemoveBuff& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(oServerRemoveBuff* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .oIdentity roles = 3;
  int roles_size() const;
  void clear_roles();
  static const int kRolesFieldNumber = 3;
  ::oIdentity* mutable_roles(int index);
  ::google::protobuf::RepeatedPtrField< ::oIdentity >*
      mutable_roles();
  const ::oIdentity& roles(int index) const;
  ::oIdentity* add_roles();
  const ::google::protobuf::RepeatedPtrField< ::oIdentity >&
      roles() const;

  // .oIdentity buffid = 1;
  bool has_buffid() const;
  void clear_buffid();
  static const int kBuffidFieldNumber = 1;
  private:
  const ::oIdentity& _internal_buffid() const;
  public:
  const ::oIdentity& buffid() const;
  ::oIdentity* release_buffid();
  ::oIdentity* mutable_buffid();
  void set_allocated_buffid(::oIdentity* buffid);

  // int32 configid = 2;
  void clear_configid();
  static const int kConfigidFieldNumber = 2;
  ::google::protobuf::int32 configid() const;
  void set_configid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:oServerRemoveBuff)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::oIdentity > roles_;
  ::oIdentity* buffid_;
  ::google::protobuf::int32 configid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class oServerResumeGamePush : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oServerResumeGamePush) */ {
 public:
  oServerResumeGamePush();
  virtual ~oServerResumeGamePush();

  oServerResumeGamePush(const oServerResumeGamePush& from);

  inline oServerResumeGamePush& operator=(const oServerResumeGamePush& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  oServerResumeGamePush(oServerResumeGamePush&& from) noexcept
    : oServerResumeGamePush() {
    *this = ::std::move(from);
  }

  inline oServerResumeGamePush& operator=(oServerResumeGamePush&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const oServerResumeGamePush& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const oServerResumeGamePush* internal_default_instance() {
    return reinterpret_cast<const oServerResumeGamePush*>(
               &_oServerResumeGamePush_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(oServerResumeGamePush* other);
  friend void swap(oServerResumeGamePush& a, oServerResumeGamePush& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline oServerResumeGamePush* New() const final {
    return CreateMaybeMessage<oServerResumeGamePush>(NULL);
  }

  oServerResumeGamePush* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<oServerResumeGamePush>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const oServerResumeGamePush& from);
  void MergeFrom(const oServerResumeGamePush& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(oServerResumeGamePush* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .oMatcherInfo matcher_info = 3;
  int matcher_info_size() const;
  void clear_matcher_info();
  static const int kMatcherInfoFieldNumber = 3;
  ::oMatcherInfo* mutable_matcher_info(int index);
  ::google::protobuf::RepeatedPtrField< ::oMatcherInfo >*
      mutable_matcher_info();
  const ::oMatcherInfo& matcher_info(int index) const;
  ::oMatcherInfo* add_matcher_info();
  const ::google::protobuf::RepeatedPtrField< ::oMatcherInfo >&
      matcher_info() const;

  // repeated .oRolesInfo roles = 4;
  int roles_size() const;
  void clear_roles();
  static const int kRolesFieldNumber = 4;
  ::oRolesInfo* mutable_roles(int index);
  ::google::protobuf::RepeatedPtrField< ::oRolesInfo >*
      mutable_roles();
  const ::oRolesInfo& roles(int index) const;
  ::oRolesInfo* add_roles();
  const ::google::protobuf::RepeatedPtrField< ::oRolesInfo >&
      roles() const;

  // repeated .oServerCreateBuff buffs = 5;
  int buffs_size() const;
  void clear_buffs();
  static const int kBuffsFieldNumber = 5;
  ::oServerCreateBuff* mutable_buffs(int index);
  ::google::protobuf::RepeatedPtrField< ::oServerCreateBuff >*
      mutable_buffs();
  const ::oServerCreateBuff& buffs(int index) const;
  ::oServerCreateBuff* add_buffs();
  const ::google::protobuf::RepeatedPtrField< ::oServerCreateBuff >&
      buffs() const;

  // repeated .oServerCreateSceneEffect effects = 6;
  int effects_size() const;
  void clear_effects();
  static const int kEffectsFieldNumber = 6;
  ::oServerCreateSceneEffect* mutable_effects(int index);
  ::google::protobuf::RepeatedPtrField< ::oServerCreateSceneEffect >*
      mutable_effects();
  const ::oServerCreateSceneEffect& effects(int index) const;
  ::oServerCreateSceneEffect* add_effects();
  const ::google::protobuf::RepeatedPtrField< ::oServerCreateSceneEffect >&
      effects() const;

  // .oUnit scene = 1;
  bool has_scene() const;
  void clear_scene();
  static const int kSceneFieldNumber = 1;
  private:
  const ::oUnit& _internal_scene() const;
  public:
  const ::oUnit& scene() const;
  ::oUnit* release_scene();
  ::oUnit* mutable_scene();
  void set_allocated_scene(::oUnit* scene);

  // .oServerRoleQueueUpdatePush role_queue = 7;
  bool has_role_queue() const;
  void clear_role_queue();
  static const int kRoleQueueFieldNumber = 7;
  private:
  const ::oServerRoleQueueUpdatePush& _internal_role_queue() const;
  public:
  const ::oServerRoleQueueUpdatePush& role_queue() const;
  ::oServerRoleQueueUpdatePush* release_role_queue();
  ::oServerRoleQueueUpdatePush* mutable_role_queue();
  void set_allocated_role_queue(::oServerRoleQueueUpdatePush* role_queue);

  // .eGameState player_state = 2;
  void clear_player_state();
  static const int kPlayerStateFieldNumber = 2;
  ::eGameState player_state() const;
  void set_player_state(::eGameState value);

  // @@protoc_insertion_point(class_scope:oServerResumeGamePush)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::oMatcherInfo > matcher_info_;
  ::google::protobuf::RepeatedPtrField< ::oRolesInfo > roles_;
  ::google::protobuf::RepeatedPtrField< ::oServerCreateBuff > buffs_;
  ::google::protobuf::RepeatedPtrField< ::oServerCreateSceneEffect > effects_;
  ::oUnit* scene_;
  ::oServerRoleQueueUpdatePush* role_queue_;
  int player_state_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class oServerGameOverPush : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oServerGameOverPush) */ {
 public:
  oServerGameOverPush();
  virtual ~oServerGameOverPush();

  oServerGameOverPush(const oServerGameOverPush& from);

  inline oServerGameOverPush& operator=(const oServerGameOverPush& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  oServerGameOverPush(oServerGameOverPush&& from) noexcept
    : oServerGameOverPush() {
    *this = ::std::move(from);
  }

  inline oServerGameOverPush& operator=(oServerGameOverPush&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const oServerGameOverPush& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const oServerGameOverPush* internal_default_instance() {
    return reinterpret_cast<const oServerGameOverPush*>(
               &_oServerGameOverPush_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(oServerGameOverPush* other);
  friend void swap(oServerGameOverPush& a, oServerGameOverPush& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline oServerGameOverPush* New() const final {
    return CreateMaybeMessage<oServerGameOverPush>(NULL);
  }

  oServerGameOverPush* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<oServerGameOverPush>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const oServerGameOverPush& from);
  void MergeFrom(const oServerGameOverPush& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(oServerGameOverPush* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:oServerGameOverPush)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class oServerGameStatementsPush : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:oServerGameStatementsPush) */ {
 public:
  oServerGameStatementsPush();
  virtual ~oServerGameStatementsPush();

  oServerGameStatementsPush(const oServerGameStatementsPush& from);

  inline oServerGameStatementsPush& operator=(const oServerGameStatementsPush& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  oServerGameStatementsPush(oServerGameStatementsPush&& from) noexcept
    : oServerGameStatementsPush() {
    *this = ::std::move(from);
  }

  inline oServerGameStatementsPush& operator=(oServerGameStatementsPush&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const oServerGameStatementsPush& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const oServerGameStatementsPush* internal_default_instance() {
    return reinterpret_cast<const oServerGameStatementsPush*>(
               &_oServerGameStatementsPush_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(oServerGameStatementsPush* other);
  friend void swap(oServerGameStatementsPush& a, oServerGameStatementsPush& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline oServerGameStatementsPush* New() const final {
    return CreateMaybeMessage<oServerGameStatementsPush>(NULL);
  }

  oServerGameStatementsPush* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<oServerGameStatementsPush>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const oServerGameStatementsPush& from);
  void MergeFrom(const oServerGameStatementsPush& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(oServerGameStatementsPush* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string statements_json = 2;
  void clear_statements_json();
  static const int kStatementsJsonFieldNumber = 2;
  const ::std::string& statements_json() const;
  void set_statements_json(const ::std::string& value);
  #if LANG_CXX11
  void set_statements_json(::std::string&& value);
  #endif
  void set_statements_json(const char* value);
  void set_statements_json(const char* value, size_t size);
  ::std::string* mutable_statements_json();
  ::std::string* release_statements_json();
  void set_allocated_statements_json(::std::string* statements_json);

  // .eError code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::eError code() const;
  void set_code(::eError value);

  // @@protoc_insertion_point(class_scope:oServerGameStatementsPush)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr statements_json_;
  int code_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// oClientLoginReq

// .ePlatform platform = 1;
inline void oClientLoginReq::clear_platform() {
  platform_ = 0;
}
inline ::ePlatform oClientLoginReq::platform() const {
  // @@protoc_insertion_point(field_get:oClientLoginReq.platform)
  return static_cast< ::ePlatform >(platform_);
}
inline void oClientLoginReq::set_platform(::ePlatform value) {
  
  platform_ = value;
  // @@protoc_insertion_point(field_set:oClientLoginReq.platform)
}

// int32 account = 2;
inline void oClientLoginReq::clear_account() {
  account_ = 0;
}
inline ::google::protobuf::int32 oClientLoginReq::account() const {
  // @@protoc_insertion_point(field_get:oClientLoginReq.account)
  return account_;
}
inline void oClientLoginReq::set_account(::google::protobuf::int32 value) {
  
  account_ = value;
  // @@protoc_insertion_point(field_set:oClientLoginReq.account)
}

// string token = 3;
inline void oClientLoginReq::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& oClientLoginReq::token() const {
  // @@protoc_insertion_point(field_get:oClientLoginReq.token)
  return token_.GetNoArena();
}
inline void oClientLoginReq::set_token(const ::std::string& value) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:oClientLoginReq.token)
}
#if LANG_CXX11
inline void oClientLoginReq::set_token(::std::string&& value) {
  
  token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:oClientLoginReq.token)
}
#endif
inline void oClientLoginReq::set_token(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:oClientLoginReq.token)
}
inline void oClientLoginReq::set_token(const char* value, size_t size) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:oClientLoginReq.token)
}
inline ::std::string* oClientLoginReq::mutable_token() {
  
  // @@protoc_insertion_point(field_mutable:oClientLoginReq.token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* oClientLoginReq::release_token() {
  // @@protoc_insertion_point(field_release:oClientLoginReq.token)
  
  return token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void oClientLoginReq::set_allocated_token(::std::string* token) {
  if (token != NULL) {
    
  } else {
    
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:oClientLoginReq.token)
}

// -------------------------------------------------------------------

// oServerLoginAws

// .eError code = 1;
inline void oServerLoginAws::clear_code() {
  code_ = 0;
}
inline ::eError oServerLoginAws::code() const {
  // @@protoc_insertion_point(field_get:oServerLoginAws.code)
  return static_cast< ::eError >(code_);
}
inline void oServerLoginAws::set_code(::eError value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:oServerLoginAws.code)
}

// .oIdentity account = 2;
inline bool oServerLoginAws::has_account() const {
  return this != internal_default_instance() && account_ != NULL;
}
inline const ::oIdentity& oServerLoginAws::_internal_account() const {
  return *account_;
}
inline const ::oIdentity& oServerLoginAws::account() const {
  const ::oIdentity* p = account_;
  // @@protoc_insertion_point(field_get:oServerLoginAws.account)
  return p != NULL ? *p : *reinterpret_cast<const ::oIdentity*>(
      &::_oIdentity_default_instance_);
}
inline ::oIdentity* oServerLoginAws::release_account() {
  // @@protoc_insertion_point(field_release:oServerLoginAws.account)
  
  ::oIdentity* temp = account_;
  account_ = NULL;
  return temp;
}
inline ::oIdentity* oServerLoginAws::mutable_account() {
  
  if (account_ == NULL) {
    auto* p = CreateMaybeMessage<::oIdentity>(GetArenaNoVirtual());
    account_ = p;
  }
  // @@protoc_insertion_point(field_mutable:oServerLoginAws.account)
  return account_;
}
inline void oServerLoginAws::set_allocated_account(::oIdentity* account) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(account_);
  }
  if (account) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      account = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, account, submessage_arena);
    }
    
  } else {
    
  }
  account_ = account;
  // @@protoc_insertion_point(field_set_allocated:oServerLoginAws.account)
}

// -------------------------------------------------------------------

// oClientMatchReq

// -------------------------------------------------------------------

// oMatcherInfo

// .oUnit player_info = 1;
inline bool oMatcherInfo::has_player_info() const {
  return this != internal_default_instance() && player_info_ != NULL;
}
inline const ::oUnit& oMatcherInfo::_internal_player_info() const {
  return *player_info_;
}
inline const ::oUnit& oMatcherInfo::player_info() const {
  const ::oUnit* p = player_info_;
  // @@protoc_insertion_point(field_get:oMatcherInfo.player_info)
  return p != NULL ? *p : *reinterpret_cast<const ::oUnit*>(
      &::_oUnit_default_instance_);
}
inline ::oUnit* oMatcherInfo::release_player_info() {
  // @@protoc_insertion_point(field_release:oMatcherInfo.player_info)
  
  ::oUnit* temp = player_info_;
  player_info_ = NULL;
  return temp;
}
inline ::oUnit* oMatcherInfo::mutable_player_info() {
  
  if (player_info_ == NULL) {
    auto* p = CreateMaybeMessage<::oUnit>(GetArenaNoVirtual());
    player_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:oMatcherInfo.player_info)
  return player_info_;
}
inline void oMatcherInfo::set_allocated_player_info(::oUnit* player_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(player_info_);
  }
  if (player_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      player_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, player_info, submessage_arena);
    }
    
  } else {
    
  }
  player_info_ = player_info;
  // @@protoc_insertion_point(field_set_allocated:oMatcherInfo.player_info)
}

// repeated int32 used_card_config_id = 2;
inline int oMatcherInfo::used_card_config_id_size() const {
  return used_card_config_id_.size();
}
inline void oMatcherInfo::clear_used_card_config_id() {
  used_card_config_id_.Clear();
}
inline ::google::protobuf::int32 oMatcherInfo::used_card_config_id(int index) const {
  // @@protoc_insertion_point(field_get:oMatcherInfo.used_card_config_id)
  return used_card_config_id_.Get(index);
}
inline void oMatcherInfo::set_used_card_config_id(int index, ::google::protobuf::int32 value) {
  used_card_config_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:oMatcherInfo.used_card_config_id)
}
inline void oMatcherInfo::add_used_card_config_id(::google::protobuf::int32 value) {
  used_card_config_id_.Add(value);
  // @@protoc_insertion_point(field_add:oMatcherInfo.used_card_config_id)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
oMatcherInfo::used_card_config_id() const {
  // @@protoc_insertion_point(field_list:oMatcherInfo.used_card_config_id)
  return used_card_config_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
oMatcherInfo::mutable_used_card_config_id() {
  // @@protoc_insertion_point(field_mutable_list:oMatcherInfo.used_card_config_id)
  return &used_card_config_id_;
}

// -------------------------------------------------------------------

// oServerMatchAws

// .eError code = 1;
inline void oServerMatchAws::clear_code() {
  code_ = 0;
}
inline ::eError oServerMatchAws::code() const {
  // @@protoc_insertion_point(field_get:oServerMatchAws.code)
  return static_cast< ::eError >(code_);
}
inline void oServerMatchAws::set_code(::eError value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:oServerMatchAws.code)
}

// .oUnit scene = 2;
inline bool oServerMatchAws::has_scene() const {
  return this != internal_default_instance() && scene_ != NULL;
}
inline const ::oUnit& oServerMatchAws::_internal_scene() const {
  return *scene_;
}
inline const ::oUnit& oServerMatchAws::scene() const {
  const ::oUnit* p = scene_;
  // @@protoc_insertion_point(field_get:oServerMatchAws.scene)
  return p != NULL ? *p : *reinterpret_cast<const ::oUnit*>(
      &::_oUnit_default_instance_);
}
inline ::oUnit* oServerMatchAws::release_scene() {
  // @@protoc_insertion_point(field_release:oServerMatchAws.scene)
  
  ::oUnit* temp = scene_;
  scene_ = NULL;
  return temp;
}
inline ::oUnit* oServerMatchAws::mutable_scene() {
  
  if (scene_ == NULL) {
    auto* p = CreateMaybeMessage<::oUnit>(GetArenaNoVirtual());
    scene_ = p;
  }
  // @@protoc_insertion_point(field_mutable:oServerMatchAws.scene)
  return scene_;
}
inline void oServerMatchAws::set_allocated_scene(::oUnit* scene) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(scene_);
  }
  if (scene) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      scene = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, scene, submessage_arena);
    }
    
  } else {
    
  }
  scene_ = scene;
  // @@protoc_insertion_point(field_set_allocated:oServerMatchAws.scene)
}

// repeated .oMatcherInfo matcher_info = 3;
inline int oServerMatchAws::matcher_info_size() const {
  return matcher_info_.size();
}
inline void oServerMatchAws::clear_matcher_info() {
  matcher_info_.Clear();
}
inline ::oMatcherInfo* oServerMatchAws::mutable_matcher_info(int index) {
  // @@protoc_insertion_point(field_mutable:oServerMatchAws.matcher_info)
  return matcher_info_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::oMatcherInfo >*
oServerMatchAws::mutable_matcher_info() {
  // @@protoc_insertion_point(field_mutable_list:oServerMatchAws.matcher_info)
  return &matcher_info_;
}
inline const ::oMatcherInfo& oServerMatchAws::matcher_info(int index) const {
  // @@protoc_insertion_point(field_get:oServerMatchAws.matcher_info)
  return matcher_info_.Get(index);
}
inline ::oMatcherInfo* oServerMatchAws::add_matcher_info() {
  // @@protoc_insertion_point(field_add:oServerMatchAws.matcher_info)
  return matcher_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::oMatcherInfo >&
oServerMatchAws::matcher_info() const {
  // @@protoc_insertion_point(field_list:oServerMatchAws.matcher_info)
  return matcher_info_;
}

// -------------------------------------------------------------------

// oClientCreateChallengeForFriendReq

// -------------------------------------------------------------------

// oClientJoinChallengeReq

// .oIdentity challenge_id = 1;
inline bool oClientJoinChallengeReq::has_challenge_id() const {
  return this != internal_default_instance() && challenge_id_ != NULL;
}
inline const ::oIdentity& oClientJoinChallengeReq::_internal_challenge_id() const {
  return *challenge_id_;
}
inline const ::oIdentity& oClientJoinChallengeReq::challenge_id() const {
  const ::oIdentity* p = challenge_id_;
  // @@protoc_insertion_point(field_get:oClientJoinChallengeReq.challenge_id)
  return p != NULL ? *p : *reinterpret_cast<const ::oIdentity*>(
      &::_oIdentity_default_instance_);
}
inline ::oIdentity* oClientJoinChallengeReq::release_challenge_id() {
  // @@protoc_insertion_point(field_release:oClientJoinChallengeReq.challenge_id)
  
  ::oIdentity* temp = challenge_id_;
  challenge_id_ = NULL;
  return temp;
}
inline ::oIdentity* oClientJoinChallengeReq::mutable_challenge_id() {
  
  if (challenge_id_ == NULL) {
    auto* p = CreateMaybeMessage<::oIdentity>(GetArenaNoVirtual());
    challenge_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:oClientJoinChallengeReq.challenge_id)
  return challenge_id_;
}
inline void oClientJoinChallengeReq::set_allocated_challenge_id(::oIdentity* challenge_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(challenge_id_);
  }
  if (challenge_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      challenge_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, challenge_id, submessage_arena);
    }
    
  } else {
    
  }
  challenge_id_ = challenge_id;
  // @@protoc_insertion_point(field_set_allocated:oClientJoinChallengeReq.challenge_id)
}

// -------------------------------------------------------------------

// oServerCreateChallengeForFriendAws

// .eError code = 1;
inline void oServerCreateChallengeForFriendAws::clear_code() {
  code_ = 0;
}
inline ::eError oServerCreateChallengeForFriendAws::code() const {
  // @@protoc_insertion_point(field_get:oServerCreateChallengeForFriendAws.code)
  return static_cast< ::eError >(code_);
}
inline void oServerCreateChallengeForFriendAws::set_code(::eError value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:oServerCreateChallengeForFriendAws.code)
}

// .oIdentity challenge_id = 2;
inline bool oServerCreateChallengeForFriendAws::has_challenge_id() const {
  return this != internal_default_instance() && challenge_id_ != NULL;
}
inline const ::oIdentity& oServerCreateChallengeForFriendAws::_internal_challenge_id() const {
  return *challenge_id_;
}
inline const ::oIdentity& oServerCreateChallengeForFriendAws::challenge_id() const {
  const ::oIdentity* p = challenge_id_;
  // @@protoc_insertion_point(field_get:oServerCreateChallengeForFriendAws.challenge_id)
  return p != NULL ? *p : *reinterpret_cast<const ::oIdentity*>(
      &::_oIdentity_default_instance_);
}
inline ::oIdentity* oServerCreateChallengeForFriendAws::release_challenge_id() {
  // @@protoc_insertion_point(field_release:oServerCreateChallengeForFriendAws.challenge_id)
  
  ::oIdentity* temp = challenge_id_;
  challenge_id_ = NULL;
  return temp;
}
inline ::oIdentity* oServerCreateChallengeForFriendAws::mutable_challenge_id() {
  
  if (challenge_id_ == NULL) {
    auto* p = CreateMaybeMessage<::oIdentity>(GetArenaNoVirtual());
    challenge_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:oServerCreateChallengeForFriendAws.challenge_id)
  return challenge_id_;
}
inline void oServerCreateChallengeForFriendAws::set_allocated_challenge_id(::oIdentity* challenge_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(challenge_id_);
  }
  if (challenge_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      challenge_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, challenge_id, submessage_arena);
    }
    
  } else {
    
  }
  challenge_id_ = challenge_id;
  // @@protoc_insertion_point(field_set_allocated:oServerCreateChallengeForFriendAws.challenge_id)
}

// -------------------------------------------------------------------

// oClientChallengeCancelReq

// -------------------------------------------------------------------

// oServerChallengeCancelAws

// .eError code = 1;
inline void oServerChallengeCancelAws::clear_code() {
  code_ = 0;
}
inline ::eError oServerChallengeCancelAws::code() const {
  // @@protoc_insertion_point(field_get:oServerChallengeCancelAws.code)
  return static_cast< ::eError >(code_);
}
inline void oServerChallengeCancelAws::set_code(::eError value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:oServerChallengeCancelAws.code)
}

// -------------------------------------------------------------------

// oClientGameReadyPush

// -------------------------------------------------------------------

// oRolesInfo

// .oIdentity account = 1;
inline bool oRolesInfo::has_account() const {
  return this != internal_default_instance() && account_ != NULL;
}
inline const ::oIdentity& oRolesInfo::_internal_account() const {
  return *account_;
}
inline const ::oIdentity& oRolesInfo::account() const {
  const ::oIdentity* p = account_;
  // @@protoc_insertion_point(field_get:oRolesInfo.account)
  return p != NULL ? *p : *reinterpret_cast<const ::oIdentity*>(
      &::_oIdentity_default_instance_);
}
inline ::oIdentity* oRolesInfo::release_account() {
  // @@protoc_insertion_point(field_release:oRolesInfo.account)
  
  ::oIdentity* temp = account_;
  account_ = NULL;
  return temp;
}
inline ::oIdentity* oRolesInfo::mutable_account() {
  
  if (account_ == NULL) {
    auto* p = CreateMaybeMessage<::oIdentity>(GetArenaNoVirtual());
    account_ = p;
  }
  // @@protoc_insertion_point(field_mutable:oRolesInfo.account)
  return account_;
}
inline void oRolesInfo::set_allocated_account(::oIdentity* account) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(account_);
  }
  if (account) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      account = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, account, submessage_arena);
    }
    
  } else {
    
  }
  account_ = account;
  // @@protoc_insertion_point(field_set_allocated:oRolesInfo.account)
}

// repeated .oUnit roles = 2;
inline int oRolesInfo::roles_size() const {
  return roles_.size();
}
inline ::oUnit* oRolesInfo::mutable_roles(int index) {
  // @@protoc_insertion_point(field_mutable:oRolesInfo.roles)
  return roles_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::oUnit >*
oRolesInfo::mutable_roles() {
  // @@protoc_insertion_point(field_mutable_list:oRolesInfo.roles)
  return &roles_;
}
inline const ::oUnit& oRolesInfo::roles(int index) const {
  // @@protoc_insertion_point(field_get:oRolesInfo.roles)
  return roles_.Get(index);
}
inline ::oUnit* oRolesInfo::add_roles() {
  // @@protoc_insertion_point(field_add:oRolesInfo.roles)
  return roles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::oUnit >&
oRolesInfo::roles() const {
  // @@protoc_insertion_point(field_list:oRolesInfo.roles)
  return roles_;
}

// -------------------------------------------------------------------

// oServerGameStartPush

// repeated .oRolesInfo info = 1;
inline int oServerGameStartPush::info_size() const {
  return info_.size();
}
inline void oServerGameStartPush::clear_info() {
  info_.Clear();
}
inline ::oRolesInfo* oServerGameStartPush::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:oServerGameStartPush.info)
  return info_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::oRolesInfo >*
oServerGameStartPush::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:oServerGameStartPush.info)
  return &info_;
}
inline const ::oRolesInfo& oServerGameStartPush::info(int index) const {
  // @@protoc_insertion_point(field_get:oServerGameStartPush.info)
  return info_.Get(index);
}
inline ::oRolesInfo* oServerGameStartPush::add_info() {
  // @@protoc_insertion_point(field_add:oServerGameStartPush.info)
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::oRolesInfo >&
oServerGameStartPush::info() const {
  // @@protoc_insertion_point(field_list:oServerGameStartPush.info)
  return info_;
}

// -------------------------------------------------------------------

// oClientSoldiersGoToBattlePush

// int32 orbit_number = 1;
inline void oClientSoldiersGoToBattlePush::clear_orbit_number() {
  orbit_number_ = 0;
}
inline ::google::protobuf::int32 oClientSoldiersGoToBattlePush::orbit_number() const {
  // @@protoc_insertion_point(field_get:oClientSoldiersGoToBattlePush.orbit_number)
  return orbit_number_;
}
inline void oClientSoldiersGoToBattlePush::set_orbit_number(::google::protobuf::int32 value) {
  
  orbit_number_ = value;
  // @@protoc_insertion_point(field_set:oClientSoldiersGoToBattlePush.orbit_number)
}

// -------------------------------------------------------------------

// oServerRolesGoToBattlePush

// .oIdentity account = 1;
inline bool oServerRolesGoToBattlePush::has_account() const {
  return this != internal_default_instance() && account_ != NULL;
}
inline const ::oIdentity& oServerRolesGoToBattlePush::_internal_account() const {
  return *account_;
}
inline const ::oIdentity& oServerRolesGoToBattlePush::account() const {
  const ::oIdentity* p = account_;
  // @@protoc_insertion_point(field_get:oServerRolesGoToBattlePush.account)
  return p != NULL ? *p : *reinterpret_cast<const ::oIdentity*>(
      &::_oIdentity_default_instance_);
}
inline ::oIdentity* oServerRolesGoToBattlePush::release_account() {
  // @@protoc_insertion_point(field_release:oServerRolesGoToBattlePush.account)
  
  ::oIdentity* temp = account_;
  account_ = NULL;
  return temp;
}
inline ::oIdentity* oServerRolesGoToBattlePush::mutable_account() {
  
  if (account_ == NULL) {
    auto* p = CreateMaybeMessage<::oIdentity>(GetArenaNoVirtual());
    account_ = p;
  }
  // @@protoc_insertion_point(field_mutable:oServerRolesGoToBattlePush.account)
  return account_;
}
inline void oServerRolesGoToBattlePush::set_allocated_account(::oIdentity* account) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(account_);
  }
  if (account) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      account = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, account, submessage_arena);
    }
    
  } else {
    
  }
  account_ = account;
  // @@protoc_insertion_point(field_set_allocated:oServerRolesGoToBattlePush.account)
}

// int32 orbit_number = 2;
inline void oServerRolesGoToBattlePush::clear_orbit_number() {
  orbit_number_ = 0;
}
inline ::google::protobuf::int32 oServerRolesGoToBattlePush::orbit_number() const {
  // @@protoc_insertion_point(field_get:oServerRolesGoToBattlePush.orbit_number)
  return orbit_number_;
}
inline void oServerRolesGoToBattlePush::set_orbit_number(::google::protobuf::int32 value) {
  
  orbit_number_ = value;
  // @@protoc_insertion_point(field_set:oServerRolesGoToBattlePush.orbit_number)
}

// .oUnit role = 3;
inline bool oServerRolesGoToBattlePush::has_role() const {
  return this != internal_default_instance() && role_ != NULL;
}
inline const ::oUnit& oServerRolesGoToBattlePush::_internal_role() const {
  return *role_;
}
inline const ::oUnit& oServerRolesGoToBattlePush::role() const {
  const ::oUnit* p = role_;
  // @@protoc_insertion_point(field_get:oServerRolesGoToBattlePush.role)
  return p != NULL ? *p : *reinterpret_cast<const ::oUnit*>(
      &::_oUnit_default_instance_);
}
inline ::oUnit* oServerRolesGoToBattlePush::release_role() {
  // @@protoc_insertion_point(field_release:oServerRolesGoToBattlePush.role)
  
  ::oUnit* temp = role_;
  role_ = NULL;
  return temp;
}
inline ::oUnit* oServerRolesGoToBattlePush::mutable_role() {
  
  if (role_ == NULL) {
    auto* p = CreateMaybeMessage<::oUnit>(GetArenaNoVirtual());
    role_ = p;
  }
  // @@protoc_insertion_point(field_mutable:oServerRolesGoToBattlePush.role)
  return role_;
}
inline void oServerRolesGoToBattlePush::set_allocated_role(::oUnit* role) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(role_);
  }
  if (role) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      role = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, role, submessage_arena);
    }
    
  } else {
    
  }
  role_ = role;
  // @@protoc_insertion_point(field_set_allocated:oServerRolesGoToBattlePush.role)
}

// -------------------------------------------------------------------

// oServerRoleQueueUpdatePush

// repeated .oUnit role = 1;
inline int oServerRoleQueueUpdatePush::role_size() const {
  return role_.size();
}
inline ::oUnit* oServerRoleQueueUpdatePush::mutable_role(int index) {
  // @@protoc_insertion_point(field_mutable:oServerRoleQueueUpdatePush.role)
  return role_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::oUnit >*
oServerRoleQueueUpdatePush::mutable_role() {
  // @@protoc_insertion_point(field_mutable_list:oServerRoleQueueUpdatePush.role)
  return &role_;
}
inline const ::oUnit& oServerRoleQueueUpdatePush::role(int index) const {
  // @@protoc_insertion_point(field_get:oServerRoleQueueUpdatePush.role)
  return role_.Get(index);
}
inline ::oUnit* oServerRoleQueueUpdatePush::add_role() {
  // @@protoc_insertion_point(field_add:oServerRoleQueueUpdatePush.role)
  return role_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::oUnit >&
oServerRoleQueueUpdatePush::role() const {
  // @@protoc_insertion_point(field_list:oServerRoleQueueUpdatePush.role)
  return role_;
}

// -------------------------------------------------------------------

// oServerRolesLeaveBattlePush

// repeated .oIdentity roles = 1;
inline int oServerRolesLeaveBattlePush::roles_size() const {
  return roles_.size();
}
inline ::oIdentity* oServerRolesLeaveBattlePush::mutable_roles(int index) {
  // @@protoc_insertion_point(field_mutable:oServerRolesLeaveBattlePush.roles)
  return roles_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::oIdentity >*
oServerRolesLeaveBattlePush::mutable_roles() {
  // @@protoc_insertion_point(field_mutable_list:oServerRolesLeaveBattlePush.roles)
  return &roles_;
}
inline const ::oIdentity& oServerRolesLeaveBattlePush::roles(int index) const {
  // @@protoc_insertion_point(field_get:oServerRolesLeaveBattlePush.roles)
  return roles_.Get(index);
}
inline ::oIdentity* oServerRolesLeaveBattlePush::add_roles() {
  // @@protoc_insertion_point(field_add:oServerRolesLeaveBattlePush.roles)
  return roles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::oIdentity >&
oServerRolesLeaveBattlePush::roles() const {
  // @@protoc_insertion_point(field_list:oServerRolesLeaveBattlePush.roles)
  return roles_;
}

// -------------------------------------------------------------------

// oCdInfo

// .oIdentity account = 1;
inline bool oCdInfo::has_account() const {
  return this != internal_default_instance() && account_ != NULL;
}
inline const ::oIdentity& oCdInfo::_internal_account() const {
  return *account_;
}
inline const ::oIdentity& oCdInfo::account() const {
  const ::oIdentity* p = account_;
  // @@protoc_insertion_point(field_get:oCdInfo.account)
  return p != NULL ? *p : *reinterpret_cast<const ::oIdentity*>(
      &::_oIdentity_default_instance_);
}
inline ::oIdentity* oCdInfo::release_account() {
  // @@protoc_insertion_point(field_release:oCdInfo.account)
  
  ::oIdentity* temp = account_;
  account_ = NULL;
  return temp;
}
inline ::oIdentity* oCdInfo::mutable_account() {
  
  if (account_ == NULL) {
    auto* p = CreateMaybeMessage<::oIdentity>(GetArenaNoVirtual());
    account_ = p;
  }
  // @@protoc_insertion_point(field_mutable:oCdInfo.account)
  return account_;
}
inline void oCdInfo::set_allocated_account(::oIdentity* account) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(account_);
  }
  if (account) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      account = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, account, submessage_arena);
    }
    
  } else {
    
  }
  account_ = account;
  // @@protoc_insertion_point(field_set_allocated:oCdInfo.account)
}

// int32 cd = 2;
inline void oCdInfo::clear_cd() {
  cd_ = 0;
}
inline ::google::protobuf::int32 oCdInfo::cd() const {
  // @@protoc_insertion_point(field_get:oCdInfo.cd)
  return cd_;
}
inline void oCdInfo::set_cd(::google::protobuf::int32 value) {
  
  cd_ = value;
  // @@protoc_insertion_point(field_set:oCdInfo.cd)
}

// -------------------------------------------------------------------

// oServerGameFrame

// repeated .oUnit roles = 1;
inline int oServerGameFrame::roles_size() const {
  return roles_.size();
}
inline ::oUnit* oServerGameFrame::mutable_roles(int index) {
  // @@protoc_insertion_point(field_mutable:oServerGameFrame.roles)
  return roles_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::oUnit >*
oServerGameFrame::mutable_roles() {
  // @@protoc_insertion_point(field_mutable_list:oServerGameFrame.roles)
  return &roles_;
}
inline const ::oUnit& oServerGameFrame::roles(int index) const {
  // @@protoc_insertion_point(field_get:oServerGameFrame.roles)
  return roles_.Get(index);
}
inline ::oUnit* oServerGameFrame::add_roles() {
  // @@protoc_insertion_point(field_add:oServerGameFrame.roles)
  return roles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::oUnit >&
oServerGameFrame::roles() const {
  // @@protoc_insertion_point(field_list:oServerGameFrame.roles)
  return roles_;
}

// repeated .oCdInfo cdinfos = 2;
inline int oServerGameFrame::cdinfos_size() const {
  return cdinfos_.size();
}
inline void oServerGameFrame::clear_cdinfos() {
  cdinfos_.Clear();
}
inline ::oCdInfo* oServerGameFrame::mutable_cdinfos(int index) {
  // @@protoc_insertion_point(field_mutable:oServerGameFrame.cdinfos)
  return cdinfos_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::oCdInfo >*
oServerGameFrame::mutable_cdinfos() {
  // @@protoc_insertion_point(field_mutable_list:oServerGameFrame.cdinfos)
  return &cdinfos_;
}
inline const ::oCdInfo& oServerGameFrame::cdinfos(int index) const {
  // @@protoc_insertion_point(field_get:oServerGameFrame.cdinfos)
  return cdinfos_.Get(index);
}
inline ::oCdInfo* oServerGameFrame::add_cdinfos() {
  // @@protoc_insertion_point(field_add:oServerGameFrame.cdinfos)
  return cdinfos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::oCdInfo >&
oServerGameFrame::cdinfos() const {
  // @@protoc_insertion_point(field_list:oServerGameFrame.cdinfos)
  return cdinfos_;
}

// int32 game_time = 3;
inline void oServerGameFrame::clear_game_time() {
  game_time_ = 0;
}
inline ::google::protobuf::int32 oServerGameFrame::game_time() const {
  // @@protoc_insertion_point(field_get:oServerGameFrame.game_time)
  return game_time_;
}
inline void oServerGameFrame::set_game_time(::google::protobuf::int32 value) {
  
  game_time_ = value;
  // @@protoc_insertion_point(field_set:oServerGameFrame.game_time)
}

// -------------------------------------------------------------------

// oServerRoleThrustingPush

// repeated .oIdentity ids = 1;
inline int oServerRoleThrustingPush::ids_size() const {
  return ids_.size();
}
inline ::oIdentity* oServerRoleThrustingPush::mutable_ids(int index) {
  // @@protoc_insertion_point(field_mutable:oServerRoleThrustingPush.ids)
  return ids_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::oIdentity >*
oServerRoleThrustingPush::mutable_ids() {
  // @@protoc_insertion_point(field_mutable_list:oServerRoleThrustingPush.ids)
  return &ids_;
}
inline const ::oIdentity& oServerRoleThrustingPush::ids(int index) const {
  // @@protoc_insertion_point(field_get:oServerRoleThrustingPush.ids)
  return ids_.Get(index);
}
inline ::oIdentity* oServerRoleThrustingPush::add_ids() {
  // @@protoc_insertion_point(field_add:oServerRoleThrustingPush.ids)
  return ids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::oIdentity >&
oServerRoleThrustingPush::ids() const {
  // @@protoc_insertion_point(field_list:oServerRoleThrustingPush.ids)
  return ids_;
}

// -------------------------------------------------------------------

// oServerPointChangePush

// .oIdentity account = 1;
inline bool oServerPointChangePush::has_account() const {
  return this != internal_default_instance() && account_ != NULL;
}
inline const ::oIdentity& oServerPointChangePush::_internal_account() const {
  return *account_;
}
inline const ::oIdentity& oServerPointChangePush::account() const {
  const ::oIdentity* p = account_;
  // @@protoc_insertion_point(field_get:oServerPointChangePush.account)
  return p != NULL ? *p : *reinterpret_cast<const ::oIdentity*>(
      &::_oIdentity_default_instance_);
}
inline ::oIdentity* oServerPointChangePush::release_account() {
  // @@protoc_insertion_point(field_release:oServerPointChangePush.account)
  
  ::oIdentity* temp = account_;
  account_ = NULL;
  return temp;
}
inline ::oIdentity* oServerPointChangePush::mutable_account() {
  
  if (account_ == NULL) {
    auto* p = CreateMaybeMessage<::oIdentity>(GetArenaNoVirtual());
    account_ = p;
  }
  // @@protoc_insertion_point(field_mutable:oServerPointChangePush.account)
  return account_;
}
inline void oServerPointChangePush::set_allocated_account(::oIdentity* account) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(account_);
  }
  if (account) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      account = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, account, submessage_arena);
    }
    
  } else {
    
  }
  account_ = account;
  // @@protoc_insertion_point(field_set_allocated:oServerPointChangePush.account)
}

// int32 point = 2;
inline void oServerPointChangePush::clear_point() {
  point_ = 0;
}
inline ::google::protobuf::int32 oServerPointChangePush::point() const {
  // @@protoc_insertion_point(field_get:oServerPointChangePush.point)
  return point_;
}
inline void oServerPointChangePush::set_point(::google::protobuf::int32 value) {
  
  point_ = value;
  // @@protoc_insertion_point(field_set:oServerPointChangePush.point)
}

// -------------------------------------------------------------------

// oServerCreateSceneEffect

// .oIdentity effectid = 1;
inline bool oServerCreateSceneEffect::has_effectid() const {
  return this != internal_default_instance() && effectid_ != NULL;
}
inline const ::oIdentity& oServerCreateSceneEffect::_internal_effectid() const {
  return *effectid_;
}
inline const ::oIdentity& oServerCreateSceneEffect::effectid() const {
  const ::oIdentity* p = effectid_;
  // @@protoc_insertion_point(field_get:oServerCreateSceneEffect.effectid)
  return p != NULL ? *p : *reinterpret_cast<const ::oIdentity*>(
      &::_oIdentity_default_instance_);
}
inline ::oIdentity* oServerCreateSceneEffect::release_effectid() {
  // @@protoc_insertion_point(field_release:oServerCreateSceneEffect.effectid)
  
  ::oIdentity* temp = effectid_;
  effectid_ = NULL;
  return temp;
}
inline ::oIdentity* oServerCreateSceneEffect::mutable_effectid() {
  
  if (effectid_ == NULL) {
    auto* p = CreateMaybeMessage<::oIdentity>(GetArenaNoVirtual());
    effectid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:oServerCreateSceneEffect.effectid)
  return effectid_;
}
inline void oServerCreateSceneEffect::set_allocated_effectid(::oIdentity* effectid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(effectid_);
  }
  if (effectid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      effectid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, effectid, submessage_arena);
    }
    
  } else {
    
  }
  effectid_ = effectid;
  // @@protoc_insertion_point(field_set_allocated:oServerCreateSceneEffect.effectid)
}

// int32 configid = 2;
inline void oServerCreateSceneEffect::clear_configid() {
  configid_ = 0;
}
inline ::google::protobuf::int32 oServerCreateSceneEffect::configid() const {
  // @@protoc_insertion_point(field_get:oServerCreateSceneEffect.configid)
  return configid_;
}
inline void oServerCreateSceneEffect::set_configid(::google::protobuf::int32 value) {
  
  configid_ = value;
  // @@protoc_insertion_point(field_set:oServerCreateSceneEffect.configid)
}

// int32 oribt_number = 3;
inline void oServerCreateSceneEffect::clear_oribt_number() {
  oribt_number_ = 0;
}
inline ::google::protobuf::int32 oServerCreateSceneEffect::oribt_number() const {
  // @@protoc_insertion_point(field_get:oServerCreateSceneEffect.oribt_number)
  return oribt_number_;
}
inline void oServerCreateSceneEffect::set_oribt_number(::google::protobuf::int32 value) {
  
  oribt_number_ = value;
  // @@protoc_insertion_point(field_set:oServerCreateSceneEffect.oribt_number)
}

// -------------------------------------------------------------------

// oServerRemoveSceneEffect

// .oIdentity effectid = 1;
inline bool oServerRemoveSceneEffect::has_effectid() const {
  return this != internal_default_instance() && effectid_ != NULL;
}
inline const ::oIdentity& oServerRemoveSceneEffect::_internal_effectid() const {
  return *effectid_;
}
inline const ::oIdentity& oServerRemoveSceneEffect::effectid() const {
  const ::oIdentity* p = effectid_;
  // @@protoc_insertion_point(field_get:oServerRemoveSceneEffect.effectid)
  return p != NULL ? *p : *reinterpret_cast<const ::oIdentity*>(
      &::_oIdentity_default_instance_);
}
inline ::oIdentity* oServerRemoveSceneEffect::release_effectid() {
  // @@protoc_insertion_point(field_release:oServerRemoveSceneEffect.effectid)
  
  ::oIdentity* temp = effectid_;
  effectid_ = NULL;
  return temp;
}
inline ::oIdentity* oServerRemoveSceneEffect::mutable_effectid() {
  
  if (effectid_ == NULL) {
    auto* p = CreateMaybeMessage<::oIdentity>(GetArenaNoVirtual());
    effectid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:oServerRemoveSceneEffect.effectid)
  return effectid_;
}
inline void oServerRemoveSceneEffect::set_allocated_effectid(::oIdentity* effectid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(effectid_);
  }
  if (effectid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      effectid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, effectid, submessage_arena);
    }
    
  } else {
    
  }
  effectid_ = effectid;
  // @@protoc_insertion_point(field_set_allocated:oServerRemoveSceneEffect.effectid)
}

// -------------------------------------------------------------------

// oServerCastSkillPush

// .oIdentity caster = 1;
inline bool oServerCastSkillPush::has_caster() const {
  return this != internal_default_instance() && caster_ != NULL;
}
inline const ::oIdentity& oServerCastSkillPush::_internal_caster() const {
  return *caster_;
}
inline const ::oIdentity& oServerCastSkillPush::caster() const {
  const ::oIdentity* p = caster_;
  // @@protoc_insertion_point(field_get:oServerCastSkillPush.caster)
  return p != NULL ? *p : *reinterpret_cast<const ::oIdentity*>(
      &::_oIdentity_default_instance_);
}
inline ::oIdentity* oServerCastSkillPush::release_caster() {
  // @@protoc_insertion_point(field_release:oServerCastSkillPush.caster)
  
  ::oIdentity* temp = caster_;
  caster_ = NULL;
  return temp;
}
inline ::oIdentity* oServerCastSkillPush::mutable_caster() {
  
  if (caster_ == NULL) {
    auto* p = CreateMaybeMessage<::oIdentity>(GetArenaNoVirtual());
    caster_ = p;
  }
  // @@protoc_insertion_point(field_mutable:oServerCastSkillPush.caster)
  return caster_;
}
inline void oServerCastSkillPush::set_allocated_caster(::oIdentity* caster) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(caster_);
  }
  if (caster) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      caster = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, caster, submessage_arena);
    }
    
  } else {
    
  }
  caster_ = caster;
  // @@protoc_insertion_point(field_set_allocated:oServerCastSkillPush.caster)
}

// int32 skillid = 2;
inline void oServerCastSkillPush::clear_skillid() {
  skillid_ = 0;
}
inline ::google::protobuf::int32 oServerCastSkillPush::skillid() const {
  // @@protoc_insertion_point(field_get:oServerCastSkillPush.skillid)
  return skillid_;
}
inline void oServerCastSkillPush::set_skillid(::google::protobuf::int32 value) {
  
  skillid_ = value;
  // @@protoc_insertion_point(field_set:oServerCastSkillPush.skillid)
}

// repeated .oIdentity roles = 3;
inline int oServerCastSkillPush::roles_size() const {
  return roles_.size();
}
inline ::oIdentity* oServerCastSkillPush::mutable_roles(int index) {
  // @@protoc_insertion_point(field_mutable:oServerCastSkillPush.roles)
  return roles_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::oIdentity >*
oServerCastSkillPush::mutable_roles() {
  // @@protoc_insertion_point(field_mutable_list:oServerCastSkillPush.roles)
  return &roles_;
}
inline const ::oIdentity& oServerCastSkillPush::roles(int index) const {
  // @@protoc_insertion_point(field_get:oServerCastSkillPush.roles)
  return roles_.Get(index);
}
inline ::oIdentity* oServerCastSkillPush::add_roles() {
  // @@protoc_insertion_point(field_add:oServerCastSkillPush.roles)
  return roles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::oIdentity >&
oServerCastSkillPush::roles() const {
  // @@protoc_insertion_point(field_list:oServerCastSkillPush.roles)
  return roles_;
}

// -------------------------------------------------------------------

// oServerCreateBuff

// .oIdentity buffid = 1;
inline bool oServerCreateBuff::has_buffid() const {
  return this != internal_default_instance() && buffid_ != NULL;
}
inline const ::oIdentity& oServerCreateBuff::_internal_buffid() const {
  return *buffid_;
}
inline const ::oIdentity& oServerCreateBuff::buffid() const {
  const ::oIdentity* p = buffid_;
  // @@protoc_insertion_point(field_get:oServerCreateBuff.buffid)
  return p != NULL ? *p : *reinterpret_cast<const ::oIdentity*>(
      &::_oIdentity_default_instance_);
}
inline ::oIdentity* oServerCreateBuff::release_buffid() {
  // @@protoc_insertion_point(field_release:oServerCreateBuff.buffid)
  
  ::oIdentity* temp = buffid_;
  buffid_ = NULL;
  return temp;
}
inline ::oIdentity* oServerCreateBuff::mutable_buffid() {
  
  if (buffid_ == NULL) {
    auto* p = CreateMaybeMessage<::oIdentity>(GetArenaNoVirtual());
    buffid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:oServerCreateBuff.buffid)
  return buffid_;
}
inline void oServerCreateBuff::set_allocated_buffid(::oIdentity* buffid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(buffid_);
  }
  if (buffid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      buffid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, buffid, submessage_arena);
    }
    
  } else {
    
  }
  buffid_ = buffid;
  // @@protoc_insertion_point(field_set_allocated:oServerCreateBuff.buffid)
}

// int32 configid = 2;
inline void oServerCreateBuff::clear_configid() {
  configid_ = 0;
}
inline ::google::protobuf::int32 oServerCreateBuff::configid() const {
  // @@protoc_insertion_point(field_get:oServerCreateBuff.configid)
  return configid_;
}
inline void oServerCreateBuff::set_configid(::google::protobuf::int32 value) {
  
  configid_ = value;
  // @@protoc_insertion_point(field_set:oServerCreateBuff.configid)
}

// repeated .oIdentity roles = 3;
inline int oServerCreateBuff::roles_size() const {
  return roles_.size();
}
inline ::oIdentity* oServerCreateBuff::mutable_roles(int index) {
  // @@protoc_insertion_point(field_mutable:oServerCreateBuff.roles)
  return roles_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::oIdentity >*
oServerCreateBuff::mutable_roles() {
  // @@protoc_insertion_point(field_mutable_list:oServerCreateBuff.roles)
  return &roles_;
}
inline const ::oIdentity& oServerCreateBuff::roles(int index) const {
  // @@protoc_insertion_point(field_get:oServerCreateBuff.roles)
  return roles_.Get(index);
}
inline ::oIdentity* oServerCreateBuff::add_roles() {
  // @@protoc_insertion_point(field_add:oServerCreateBuff.roles)
  return roles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::oIdentity >&
oServerCreateBuff::roles() const {
  // @@protoc_insertion_point(field_list:oServerCreateBuff.roles)
  return roles_;
}

// -------------------------------------------------------------------

// oServerRemoveBuff

// .oIdentity buffid = 1;
inline bool oServerRemoveBuff::has_buffid() const {
  return this != internal_default_instance() && buffid_ != NULL;
}
inline const ::oIdentity& oServerRemoveBuff::_internal_buffid() const {
  return *buffid_;
}
inline const ::oIdentity& oServerRemoveBuff::buffid() const {
  const ::oIdentity* p = buffid_;
  // @@protoc_insertion_point(field_get:oServerRemoveBuff.buffid)
  return p != NULL ? *p : *reinterpret_cast<const ::oIdentity*>(
      &::_oIdentity_default_instance_);
}
inline ::oIdentity* oServerRemoveBuff::release_buffid() {
  // @@protoc_insertion_point(field_release:oServerRemoveBuff.buffid)
  
  ::oIdentity* temp = buffid_;
  buffid_ = NULL;
  return temp;
}
inline ::oIdentity* oServerRemoveBuff::mutable_buffid() {
  
  if (buffid_ == NULL) {
    auto* p = CreateMaybeMessage<::oIdentity>(GetArenaNoVirtual());
    buffid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:oServerRemoveBuff.buffid)
  return buffid_;
}
inline void oServerRemoveBuff::set_allocated_buffid(::oIdentity* buffid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(buffid_);
  }
  if (buffid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      buffid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, buffid, submessage_arena);
    }
    
  } else {
    
  }
  buffid_ = buffid;
  // @@protoc_insertion_point(field_set_allocated:oServerRemoveBuff.buffid)
}

// int32 configid = 2;
inline void oServerRemoveBuff::clear_configid() {
  configid_ = 0;
}
inline ::google::protobuf::int32 oServerRemoveBuff::configid() const {
  // @@protoc_insertion_point(field_get:oServerRemoveBuff.configid)
  return configid_;
}
inline void oServerRemoveBuff::set_configid(::google::protobuf::int32 value) {
  
  configid_ = value;
  // @@protoc_insertion_point(field_set:oServerRemoveBuff.configid)
}

// repeated .oIdentity roles = 3;
inline int oServerRemoveBuff::roles_size() const {
  return roles_.size();
}
inline ::oIdentity* oServerRemoveBuff::mutable_roles(int index) {
  // @@protoc_insertion_point(field_mutable:oServerRemoveBuff.roles)
  return roles_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::oIdentity >*
oServerRemoveBuff::mutable_roles() {
  // @@protoc_insertion_point(field_mutable_list:oServerRemoveBuff.roles)
  return &roles_;
}
inline const ::oIdentity& oServerRemoveBuff::roles(int index) const {
  // @@protoc_insertion_point(field_get:oServerRemoveBuff.roles)
  return roles_.Get(index);
}
inline ::oIdentity* oServerRemoveBuff::add_roles() {
  // @@protoc_insertion_point(field_add:oServerRemoveBuff.roles)
  return roles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::oIdentity >&
oServerRemoveBuff::roles() const {
  // @@protoc_insertion_point(field_list:oServerRemoveBuff.roles)
  return roles_;
}

// -------------------------------------------------------------------

// oServerResumeGamePush

// .oUnit scene = 1;
inline bool oServerResumeGamePush::has_scene() const {
  return this != internal_default_instance() && scene_ != NULL;
}
inline const ::oUnit& oServerResumeGamePush::_internal_scene() const {
  return *scene_;
}
inline const ::oUnit& oServerResumeGamePush::scene() const {
  const ::oUnit* p = scene_;
  // @@protoc_insertion_point(field_get:oServerResumeGamePush.scene)
  return p != NULL ? *p : *reinterpret_cast<const ::oUnit*>(
      &::_oUnit_default_instance_);
}
inline ::oUnit* oServerResumeGamePush::release_scene() {
  // @@protoc_insertion_point(field_release:oServerResumeGamePush.scene)
  
  ::oUnit* temp = scene_;
  scene_ = NULL;
  return temp;
}
inline ::oUnit* oServerResumeGamePush::mutable_scene() {
  
  if (scene_ == NULL) {
    auto* p = CreateMaybeMessage<::oUnit>(GetArenaNoVirtual());
    scene_ = p;
  }
  // @@protoc_insertion_point(field_mutable:oServerResumeGamePush.scene)
  return scene_;
}
inline void oServerResumeGamePush::set_allocated_scene(::oUnit* scene) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(scene_);
  }
  if (scene) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      scene = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, scene, submessage_arena);
    }
    
  } else {
    
  }
  scene_ = scene;
  // @@protoc_insertion_point(field_set_allocated:oServerResumeGamePush.scene)
}

// .eGameState player_state = 2;
inline void oServerResumeGamePush::clear_player_state() {
  player_state_ = 0;
}
inline ::eGameState oServerResumeGamePush::player_state() const {
  // @@protoc_insertion_point(field_get:oServerResumeGamePush.player_state)
  return static_cast< ::eGameState >(player_state_);
}
inline void oServerResumeGamePush::set_player_state(::eGameState value) {
  
  player_state_ = value;
  // @@protoc_insertion_point(field_set:oServerResumeGamePush.player_state)
}

// repeated .oMatcherInfo matcher_info = 3;
inline int oServerResumeGamePush::matcher_info_size() const {
  return matcher_info_.size();
}
inline void oServerResumeGamePush::clear_matcher_info() {
  matcher_info_.Clear();
}
inline ::oMatcherInfo* oServerResumeGamePush::mutable_matcher_info(int index) {
  // @@protoc_insertion_point(field_mutable:oServerResumeGamePush.matcher_info)
  return matcher_info_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::oMatcherInfo >*
oServerResumeGamePush::mutable_matcher_info() {
  // @@protoc_insertion_point(field_mutable_list:oServerResumeGamePush.matcher_info)
  return &matcher_info_;
}
inline const ::oMatcherInfo& oServerResumeGamePush::matcher_info(int index) const {
  // @@protoc_insertion_point(field_get:oServerResumeGamePush.matcher_info)
  return matcher_info_.Get(index);
}
inline ::oMatcherInfo* oServerResumeGamePush::add_matcher_info() {
  // @@protoc_insertion_point(field_add:oServerResumeGamePush.matcher_info)
  return matcher_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::oMatcherInfo >&
oServerResumeGamePush::matcher_info() const {
  // @@protoc_insertion_point(field_list:oServerResumeGamePush.matcher_info)
  return matcher_info_;
}

// repeated .oRolesInfo roles = 4;
inline int oServerResumeGamePush::roles_size() const {
  return roles_.size();
}
inline void oServerResumeGamePush::clear_roles() {
  roles_.Clear();
}
inline ::oRolesInfo* oServerResumeGamePush::mutable_roles(int index) {
  // @@protoc_insertion_point(field_mutable:oServerResumeGamePush.roles)
  return roles_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::oRolesInfo >*
oServerResumeGamePush::mutable_roles() {
  // @@protoc_insertion_point(field_mutable_list:oServerResumeGamePush.roles)
  return &roles_;
}
inline const ::oRolesInfo& oServerResumeGamePush::roles(int index) const {
  // @@protoc_insertion_point(field_get:oServerResumeGamePush.roles)
  return roles_.Get(index);
}
inline ::oRolesInfo* oServerResumeGamePush::add_roles() {
  // @@protoc_insertion_point(field_add:oServerResumeGamePush.roles)
  return roles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::oRolesInfo >&
oServerResumeGamePush::roles() const {
  // @@protoc_insertion_point(field_list:oServerResumeGamePush.roles)
  return roles_;
}

// repeated .oServerCreateBuff buffs = 5;
inline int oServerResumeGamePush::buffs_size() const {
  return buffs_.size();
}
inline void oServerResumeGamePush::clear_buffs() {
  buffs_.Clear();
}
inline ::oServerCreateBuff* oServerResumeGamePush::mutable_buffs(int index) {
  // @@protoc_insertion_point(field_mutable:oServerResumeGamePush.buffs)
  return buffs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::oServerCreateBuff >*
oServerResumeGamePush::mutable_buffs() {
  // @@protoc_insertion_point(field_mutable_list:oServerResumeGamePush.buffs)
  return &buffs_;
}
inline const ::oServerCreateBuff& oServerResumeGamePush::buffs(int index) const {
  // @@protoc_insertion_point(field_get:oServerResumeGamePush.buffs)
  return buffs_.Get(index);
}
inline ::oServerCreateBuff* oServerResumeGamePush::add_buffs() {
  // @@protoc_insertion_point(field_add:oServerResumeGamePush.buffs)
  return buffs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::oServerCreateBuff >&
oServerResumeGamePush::buffs() const {
  // @@protoc_insertion_point(field_list:oServerResumeGamePush.buffs)
  return buffs_;
}

// repeated .oServerCreateSceneEffect effects = 6;
inline int oServerResumeGamePush::effects_size() const {
  return effects_.size();
}
inline void oServerResumeGamePush::clear_effects() {
  effects_.Clear();
}
inline ::oServerCreateSceneEffect* oServerResumeGamePush::mutable_effects(int index) {
  // @@protoc_insertion_point(field_mutable:oServerResumeGamePush.effects)
  return effects_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::oServerCreateSceneEffect >*
oServerResumeGamePush::mutable_effects() {
  // @@protoc_insertion_point(field_mutable_list:oServerResumeGamePush.effects)
  return &effects_;
}
inline const ::oServerCreateSceneEffect& oServerResumeGamePush::effects(int index) const {
  // @@protoc_insertion_point(field_get:oServerResumeGamePush.effects)
  return effects_.Get(index);
}
inline ::oServerCreateSceneEffect* oServerResumeGamePush::add_effects() {
  // @@protoc_insertion_point(field_add:oServerResumeGamePush.effects)
  return effects_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::oServerCreateSceneEffect >&
oServerResumeGamePush::effects() const {
  // @@protoc_insertion_point(field_list:oServerResumeGamePush.effects)
  return effects_;
}

// .oServerRoleQueueUpdatePush role_queue = 7;
inline bool oServerResumeGamePush::has_role_queue() const {
  return this != internal_default_instance() && role_queue_ != NULL;
}
inline void oServerResumeGamePush::clear_role_queue() {
  if (GetArenaNoVirtual() == NULL && role_queue_ != NULL) {
    delete role_queue_;
  }
  role_queue_ = NULL;
}
inline const ::oServerRoleQueueUpdatePush& oServerResumeGamePush::_internal_role_queue() const {
  return *role_queue_;
}
inline const ::oServerRoleQueueUpdatePush& oServerResumeGamePush::role_queue() const {
  const ::oServerRoleQueueUpdatePush* p = role_queue_;
  // @@protoc_insertion_point(field_get:oServerResumeGamePush.role_queue)
  return p != NULL ? *p : *reinterpret_cast<const ::oServerRoleQueueUpdatePush*>(
      &::_oServerRoleQueueUpdatePush_default_instance_);
}
inline ::oServerRoleQueueUpdatePush* oServerResumeGamePush::release_role_queue() {
  // @@protoc_insertion_point(field_release:oServerResumeGamePush.role_queue)
  
  ::oServerRoleQueueUpdatePush* temp = role_queue_;
  role_queue_ = NULL;
  return temp;
}
inline ::oServerRoleQueueUpdatePush* oServerResumeGamePush::mutable_role_queue() {
  
  if (role_queue_ == NULL) {
    auto* p = CreateMaybeMessage<::oServerRoleQueueUpdatePush>(GetArenaNoVirtual());
    role_queue_ = p;
  }
  // @@protoc_insertion_point(field_mutable:oServerResumeGamePush.role_queue)
  return role_queue_;
}
inline void oServerResumeGamePush::set_allocated_role_queue(::oServerRoleQueueUpdatePush* role_queue) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete role_queue_;
  }
  if (role_queue) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      role_queue = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, role_queue, submessage_arena);
    }
    
  } else {
    
  }
  role_queue_ = role_queue;
  // @@protoc_insertion_point(field_set_allocated:oServerResumeGamePush.role_queue)
}

// -------------------------------------------------------------------

// oServerGameOverPush

// -------------------------------------------------------------------

// oServerGameStatementsPush

// .eError code = 1;
inline void oServerGameStatementsPush::clear_code() {
  code_ = 0;
}
inline ::eError oServerGameStatementsPush::code() const {
  // @@protoc_insertion_point(field_get:oServerGameStatementsPush.code)
  return static_cast< ::eError >(code_);
}
inline void oServerGameStatementsPush::set_code(::eError value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:oServerGameStatementsPush.code)
}

// string statements_json = 2;
inline void oServerGameStatementsPush::clear_statements_json() {
  statements_json_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& oServerGameStatementsPush::statements_json() const {
  // @@protoc_insertion_point(field_get:oServerGameStatementsPush.statements_json)
  return statements_json_.GetNoArena();
}
inline void oServerGameStatementsPush::set_statements_json(const ::std::string& value) {
  
  statements_json_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:oServerGameStatementsPush.statements_json)
}
#if LANG_CXX11
inline void oServerGameStatementsPush::set_statements_json(::std::string&& value) {
  
  statements_json_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:oServerGameStatementsPush.statements_json)
}
#endif
inline void oServerGameStatementsPush::set_statements_json(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  statements_json_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:oServerGameStatementsPush.statements_json)
}
inline void oServerGameStatementsPush::set_statements_json(const char* value, size_t size) {
  
  statements_json_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:oServerGameStatementsPush.statements_json)
}
inline ::std::string* oServerGameStatementsPush::mutable_statements_json() {
  
  // @@protoc_insertion_point(field_mutable:oServerGameStatementsPush.statements_json)
  return statements_json_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* oServerGameStatementsPush::release_statements_json() {
  // @@protoc_insertion_point(field_release:oServerGameStatementsPush.statements_json)
  
  return statements_json_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void oServerGameStatementsPush::set_allocated_statements_json(::std::string* statements_json) {
  if (statements_json != NULL) {
    
  } else {
    
  }
  statements_json_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), statements_json);
  // @@protoc_insertion_point(field_set_allocated:oServerGameStatementsPush.statements_json)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::eError> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eError>() {
  return ::eError_descriptor();
}
template <> struct is_proto_enum< ::eCProtoID> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eCProtoID>() {
  return ::eCProtoID_descriptor();
}
template <> struct is_proto_enum< ::eSProtoID> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eSProtoID>() {
  return ::eSProtoID_descriptor();
}
template <> struct is_proto_enum< ::ePlatform> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ePlatform>() {
  return ::ePlatform_descriptor();
}
template <> struct is_proto_enum< ::eGameState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eGameState>() {
  return ::eGameState_descriptor();
}
template <> struct is_proto_enum< ::eRoleState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eRoleState>() {
  return ::eRoleState_descriptor();
}
template <> struct is_proto_enum< ::eSide> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eSide>() {
  return ::eSide_descriptor();
}
template <> struct is_proto_enum< ::eGameResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eGameResult>() {
  return ::eGameResult_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_game_2eproto
